{"id":1,"jsonrpc":"2.0","result":{"tools":[{"description":"Purpose: Return persisted plaintext SHA-256 checksum for one attachment without reading attachment payload.\nUse when: You need integrity metadata quickly and cannot afford a full payload read.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required.\nEffects: Returns metadata-derived `plaintext_sha256` for the selected attachment.\nRetry: Safe to retry; this is a read operation.\nNext: Compare against client-side checksum after `lockd.attachments.stream` if payload verification is needed.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.checksum","outputSchema":{"additionalProperties":false,"properties":{"attachment_id":{"type":"string"},"attachment_name":{"type":"string"},"key":{"type":"string"},"namespace":{"type":"string"},"plaintext_sha256":{"type":"string"}},"required":["namespace","key","attachment_id","attachment_name"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Delete a single attachment under lease protection.\nUse when: One attachment should be removed while keeping others.\nRequires: `key` and `lease_id` are required, plus either `id` or `name`. `namespace` defaults to \"mcp\". Optional `txn_id` enables XA staging. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Deletes (or stages deletion of) the targeted attachment and returns success state.\nRetry: If retrying after unknown outcome, verify attachment state first; do not assume delete status.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> verify remaining attachments and release lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.attachments.delete","outputSchema":{"additionalProperties":false,"properties":{"deleted":{"type":"boolean"},"version":{"type":"integer"}},"required":["deleted","version"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Delete all attachments for a key under lease protection.\nUse when: You need full attachment cleanup for a key.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` allows transactional staging. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Removes (or stages removal of) all attachments for the key.\nRetry: If retrying after unknown outcome, verify attachment list first; do not assume delete-all status.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> optionally write replacements and release lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.attachments.delete_all","outputSchema":{"additionalProperties":false,"properties":{"deleted":{"type":"integer"},"version":{"type":"integer"}},"required":["deleted","version"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Resolve one attachment by id or name and return metadata plus optional inline/stream payload delivery.\nUse when: You need attachment payload in either inline or streaming mode.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true; if `public=false`, `lease_id` is required and if `public=true`, `lease_id` must be omitted. `payload_mode` supports `auto` (default), `inline`, `stream`, or `none`; `auto` resolves to inline when payload bytes <= `lockd.hint.inline_max_payload_bytes`, otherwise stream.\nEffects: Returns attachment metadata/checksum and either inline payload (`payload_text` or `payload_base64`) or one-time stream URL.\nRetry: Safe to retry; this is a read operation.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> use `lockd.attachments.stream` for explicit streaming-only access and checksum for integrity checks.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_mode":{"description":"Payload mode: auto (default), inline, stream, or none","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.get","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"key":{"type":"string"},"namespace":{"type":"string"},"payload_base64":{"type":"string"},"payload_bytes":{"type":"integer"},"payload_mode":{"type":"string"},"payload_sha256":{"type":"string"},"payload_text":{"type":"string"}},"required":["namespace","key","attachment","payload_mode","payload_bytes"],"type":"object"}},{"description":"Purpose: Fetch metadata for one attachment by id or name without reading payload bytes.\nUse when: You need to inspect attachment existence/size/type before deciding whether to download content.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. If `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata only (`id`, `name`, `size`, `plaintext_sha256`, timestamps, and content type).\nRetry: Safe to retry; this is a read operation.\nNext: Call `lockd.attachments.stream` when payload content is required.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.head","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"key":{"type":"string"},"namespace":{"type":"string"}},"required":["namespace","key","attachment"],"type":"object"}},{"description":"Purpose: List attachment metadata for a key.\nUse when: You need attachment ids/names before get/delete workflows.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. If `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata only (no payload bytes).\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.attachments.head` for metadata-only lookup, `lockd.attachments.get` for payload access, or delete tools for cleanup.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.list","outputSchema":{"additionalProperties":false,"properties":{"attachments":{"items":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"type":["null","array"]},"key":{"type":"string"},"namespace":{"type":"string"}},"required":["namespace","key","attachments"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nPAYLOAD RULE: If payload size is unknown or may exceed limits, call lockd.hint and use stream workflow; do not guess.\nPurpose: Write attachment payload inline under lease protection.\nUse when: Attachment payload fits inline limits and you want a single MCP tool call write.\nRequires: `key`, `lease_id`, and `name` are required. `namespace` defaults to \"mcp\". Provide at most one of `payload_text` or `payload_base64`; decoded payload must be <= 2097152 bytes. `mode` supports `create` (default), `upsert`, `replace`. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Writes attachment bytes and returns attachment metadata/version.\nRetry: Retry only with explicit `mode`/fencing intent. Do not assume previous attempt failed; verify attachment state before replay.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- If payload may exceed inline limit -> call `lockd.attachments.write_stream.begin` for large attachment uploads.\n- Otherwise -> write attachment, then release lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"content_type":{"description":"Attachment content type","type":"string"},"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"max_bytes":{"description":"Optional upload size cap","type":"integer"},"mode":{"description":"Write mode: create (default), upsert, or replace","type":"string"},"name":{"description":"Attachment name","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_base64":{"description":"Base64-encoded payload bytes","type":"string"},"payload_text":{"description":"UTF-8 payload text","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","name"],"type":"object"},"name":"lockd.attachments.put","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"noop":{"type":"boolean"},"version":{"type":"integer"}},"required":["attachment","noop","version"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Create a one-time download capability URL for attachment payload bytes.\nUse when: You need attachment content without pushing payload through MCP tool responses.\nRequires: Active MCP session is required. `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true; if `public=false`, `lease_id` is required and if `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata plus one-time `download_url` and `download_method` for direct HTTP download.\nRetry: Safe to retry; each retry returns a new one-time URL. Do not reuse old URLs.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> fetch `download_url` directly and compare with checksum when integrity checks are needed.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.stream","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"key":{"type":"string"},"namespace":{"type":"string"}},"required":["namespace","key","attachment"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit/abort attempt (success or failure), abandon this identifier and never reuse it.\nPurpose: Abort an in-flight attachment write stream.\nUse when: Attachment upload should be canceled.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates upload flow and frees stream resources.\nRetry: Safe to retry for cleanup, but do not assume abort reopens or reuses the stream; create a new stream for any retry path.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> begin a new attachment stream if upload should be retried.","inputSchema":{"additionalProperties":false,"properties":{"reason":{"description":"Optional abort reason for diagnostics","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.attachments.write_stream.abort","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"stream_id":{"type":"string"}},"required":["stream_id","aborted","bytes_received"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Open a session-scoped streaming attachment writer.\nUse when: Attachment payload is larger than inline limit or you want streaming upload semantics.\nRequires: Active MCP session is required. `key`, `lease_id`, and `name` are required. `namespace` defaults to \"mcp\". `mode` supports `create` (default), `upsert`, `replace`.\nEffects: Creates a stream session and returns one-time `upload_url` for direct HTTP PUT upload into upstream attachment flow.\nRetry: Do not retry as idempotent. Begin creates a new stream each call; do not reuse identifiers from previous attempts.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> upload to `upload_url`, then status/commit or abort.","inputSchema":{"additionalProperties":false,"properties":{"content_type":{"description":"Attachment content type","type":"string"},"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"max_bytes":{"description":"Optional upload size cap","type":"integer"},"mode":{"description":"Write mode: create (default), upsert, or replace","type":"string"},"name":{"description":"Attachment name","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","name"],"type":"object"},"name":"lockd.attachments.write_stream.begin","outputSchema":{"additionalProperties":false,"properties":{"stream_id":{"type":"string"},"upload_expires_at_unix":{"type":"integer"},"upload_method":{"type":"string"},"upload_url":{"type":"string"}},"required":["stream_id"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit attempt (success or failure), abandon this identifier; durability still depends on successful lock release.\nPurpose: Finalize an attachment write stream.\nUse when: All attachment payload chunks have been appended.\nRequires: Active MCP session and `stream_id` are required. Optional `expected_bytes` and `expected_sha256` enforce upload integrity before commit.\nEffects: Closes the upload stream, validates optional expectations, waits for upstream attach completion, and returns attachment metadata/version. Attachment changes stay staged under the lease until `lockd.lock.release` commits (or rollback discards).\nRetry: After any commit attempt (success or failure), do not retry with the same `stream_id`. Start a new begin→upload→commit sequence.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> verify attachment metadata and release lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"expected_bytes":{"description":"Optional expected plaintext byte count of uploaded data","type":["null","integer"]},"expected_sha256":{"description":"Optional expected lowercase hex SHA-256 of uploaded plaintext bytes","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.attachments.write_stream.commit","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"bytes_received":{"type":"integer"},"noop":{"type":"boolean"},"stream_id":{"type":"string"},"version":{"type":"integer"}},"required":["stream_id","bytes_received","attachment","noop","version"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Use only the current active identifier; never continue workflows with stale identifiers.\nPurpose: Inspect in-flight attachment write-stream upload progress.\nUse when: You need upload observability before attachment commit.\nRequires: Active MCP session and `stream_id` are required.\nEffects: Returns `bytes_received`, computed `payload_sha256`, upload-capability availability/expiry, and commit-readiness flags.\nRetry: Safe to retry while stream exists.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> if `can_commit=true`, call `lockd.attachments.write_stream.commit`; otherwise finish upload or abort.","inputSchema":{"additionalProperties":false,"properties":{"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.attachments.write_stream.status","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"can_commit":{"type":"boolean"},"committing":{"type":"boolean"},"payload_sha256":{"type":"string"},"stream_id":{"type":"string"},"upload_capability_available":{"type":"boolean"},"upload_completed":{"type":"boolean"},"upload_expires_at_unix":{"type":"integer"},"upload_in_progress":{"type":"boolean"}},"required":["stream_id","bytes_received","upload_capability_available","upload_completed","upload_in_progress","committing","aborted","can_commit"],"type":"object"}},{"description":"Purpose: Read key metadata (lease owner, version, ETag, timestamps) without returning state payload.\nUse when: You need lock/version metadata for diagnostics, conflict handling, or coordination checks.\nRequires: `key` is required. `namespace` defaults to \"mcp\" when omitted.\nEffects: Returns metadata snapshot only; does not mutate state.\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.get` to read payload or lock tools for mutation workflows.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"Lock key to inspect","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.describe","outputSchema":{"additionalProperties":false,"properties":{"expires_at_unix":{"type":"integer"},"key":{"type":"string"},"lease_id":{"type":"string"},"namespace":{"type":"string"},"owner":{"type":"string"},"query_hidden":{"type":["null","boolean"]},"state_etag":{"type":"string"},"updated_at_unix":{"type":"integer"},"version":{"type":"integer"}},"required":["namespace","key","version"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Read committed JSON state for one key.\nUse when: You need key metadata and optionally payload bytes in inline or streaming mode.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. `payload_mode` supports `auto` (default), `inline`, `stream`, or `none`; `auto` resolves to inline when payload bytes <= `lockd.hint.inline_max_payload_bytes`, otherwise stream.\nEffects: Returns metadata plus either inline payload (`payload_text` or `payload_base64`) or one-time stream download URL, depending on `payload_mode` and payload size.\nRetry: Safe to retry; this is a read operation.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> use `lockd.state.stream` for explicit streaming-only reads or acquire a lock before mutation.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"Lock key to read","type":"string"},"lease_id":{"description":"Lease ID required when public=false","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_mode":{"description":"Payload mode: auto (default), inline, stream, or none","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]}},"required":["key"],"type":"object"},"name":"lockd.get","outputSchema":{"additionalProperties":false,"properties":{"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"etag":{"type":"string"},"found":{"type":"boolean"},"key":{"type":"string"},"namespace":{"type":"string"},"payload_base64":{"type":"string"},"payload_bytes":{"type":"integer"},"payload_mode":{"type":"string"},"payload_text":{"type":"string"},"version":{"type":"integer"}},"required":["namespace","key","found","payload_mode"],"type":"object"}},{"description":"Purpose: Return curated lockd MCP workflows, invariants, and documentation resource URIs.\nUse when: Start of session or when uncertain about correct operation sequence.\nRequires: No required fields. Optional `topic` narrows guidance to overview/locks/messaging/sync/lql.\nEffects: Returns guidance only; no lockd state mutation occurs.\nRetry: Safe to retry.\nNext: Follow `next_calls` in the response, typically beginning with lock, queue, or query tools.","inputSchema":{"additionalProperties":false,"properties":{"topic":{"description":"Optional topic: overview, locks, messaging, sync, lql","type":"string"}},"type":"object"},"name":"lockd.help","outputSchema":{"additionalProperties":false,"properties":{"defaults":{"additionalProperties":{"type":"string"},"type":"object"},"invariants":{"items":{"type":"string"},"type":["null","array"]},"next_calls":{"items":{"type":"string"},"type":["null","array"]},"resources":{"items":{"type":"string"},"type":["null","array"]},"summary":{"type":"string"},"topic":{"type":"string"}},"required":["topic","summary","next_calls","resources","defaults","invariants"],"type":"object"}},{"description":"Purpose: Return namespace access hints so agents can choose valid namespaces before doing work.\nUse when: Session start, planning phase, or when namespace-forbidden errors occur.\nRequires: No required fields. Uses current caller token context plus upstream client-bundle namespace claims when available.\nEffects: Returns advisory namespace access hints, default namespace, inline payload limit (`inline_max_payload_bytes`), client id, and token scope context.\nRetry: Safe to retry; this is a read-only advisory operation.\nNext: Call `lockd.help` then use returned namespace hints when invoking lock/query/queue tools.","inputSchema":{"additionalProperties":false,"type":"object"},"name":"lockd.hint","outputSchema":{"additionalProperties":false,"properties":{"claim_uris":{"items":{"type":"string"},"type":["null","array"]},"client_id":{"type":"string"},"default_namespace":{"type":"string"},"inline_max_payload_bytes":{"type":"integer"},"namespace_hints":{"items":{"additionalProperties":false,"properties":{"namespace":{"type":"string"},"permission":{"type":"string"}},"required":["namespace","permission"],"type":"object"},"type":["null","array"]},"notes":{"items":{"type":"string"},"type":["null","array"]},"source":{"type":"string"},"token_scopes":{"items":{"type":"string"},"type":["null","array"]},"wildcard_permission":{"type":"string"}},"required":["default_namespace","inline_max_payload_bytes","source"],"type":"object"}},{"description":"Purpose: Trigger search index flush for a namespace.\nUse when: You need query index freshness guarantees after heavy writes or before time-sensitive reads.\nRequires: `namespace` defaults to \"mcp\". `mode` may be `async` (default) or `wait`.\nEffects: Schedules or waits for index flush and returns flush progress metadata.\nRetry: Safe to retry; repeated flush requests are operationally benign.\nNext: Run `lockd.query` to observe refreshed index results.","inputSchema":{"additionalProperties":false,"properties":{"mode":{"description":"Flush mode: async (default) or wait","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"}},"type":"object"},"name":"lockd.index.flush","outputSchema":{"additionalProperties":false,"properties":{"accepted":{"type":"boolean"},"flush_id":{"type":"string"},"flushed":{"type":"boolean"},"index_seq":{"minimum":0,"type":"integer"},"mode":{"type":"string"},"namespace":{"type":"string"},"pending":{"type":"boolean"}},"required":["namespace","mode","accepted","flushed","pending"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Lease/fencing identifiers are authoritative for this workflow only; never invent or reuse stale values.\nPurpose: Acquire an exclusive lock lease and receive the lease identity/fencing material needed for protected writes.\nUse when: You need to mutate shared state or attachments for a key, or you need exclusive coordination ownership.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `owner` defaults to OAuth client id. Optional `txn_id` enlists the lease in XA flow. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Creates or claims a lease and returns `lease_id`, `fencing_token`, expiry, and optional `txn_id` for follow-up tools.\nRetry: Do not retry by reusing old lease/fencing values. If acquire fails or expires, run acquire again and continue with the new identifiers only.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> call `lockd.state.update` or attachment tools, keep lease alive while working, then `lockd.lock.release`.","inputSchema":{"additionalProperties":false,"properties":{"block_seconds":{"description":"Acquire wait: -1 no wait, 0 wait forever, >0 wait seconds","type":"integer"},"if_not_exists":{"description":"Create-only acquire","type":"boolean"},"key":{"description":"Key to lock","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"owner":{"description":"Lock owner (defaults to oauth client id)","type":"string"},"ttl_seconds":{"description":"Lease TTL in seconds","type":"integer"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.lock.acquire","outputSchema":{"additionalProperties":false,"properties":{"correlation_id":{"type":"string"},"expires_at_unix":{"type":"integer"},"fencing_token":{"type":"integer"},"key":{"type":"string"},"lease_id":{"type":"string"},"namespace":{"type":"string"},"owner":{"type":"string"},"state_etag":{"type":"string"},"txn_id":{"type":"string"},"version":{"type":"integer"}},"required":["namespace","key","lease_id","owner","expires_at_unix","version"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Lease/fencing identifiers are authoritative for this workflow only; never invent or reuse stale values.\nPurpose: Extend an active lock lease TTL.\nUse when: Long-running work might outlive current lease expiry.\nRequires: `key`, `lease_id`, and `ttl_seconds > 0` are required. `namespace` defaults to \"mcp\". Optional `txn_id` keeps XA context consistent. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Extends lease expiry and returns the updated expiration timestamp.\nRetry: Retry with the same `lease_id` only while lease is still valid. If lease may be expired or ownership changed, do not keepalive stale identifiers; reacquire first.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue mutation workflow; keepalive as needed until ready to release.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"Locked key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"ttl_seconds":{"description":"TTL extension in seconds","type":"integer"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","ttl_seconds"],"type":"object"},"name":"lockd.lock.keepalive","outputSchema":{"additionalProperties":false,"properties":{"expires_at_unix":{"type":"integer"}},"required":["expires_at_unix"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Release a lease and finalize staged changes.\nUse when: Work under a lease is complete or must be abandoned.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` and `rollback=true` control XA/rollback behavior. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Releases lease ownership. Commits staged changes by default; rolls back when `rollback=true`.\nRetry: Retry is conditionally safe after transport failures, but do not assume commit or rollback occurred until you verify resulting state/version.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> release, verify resulting state, and reacquire later only if more work is needed.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"Locked key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"rollback":{"description":"Rollback staged changes instead of commit","type":"boolean"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.lock.release","outputSchema":{"additionalProperties":false,"properties":{"released":{"type":"boolean"}},"required":["released"],"type":"object"}},{"description":"Purpose: Read namespace query-engine configuration.\nUse when: You need to inspect current query engine settings before updates or debugging.\nRequires: `namespace` defaults to \"mcp\" when omitted.\nEffects: Returns effective namespace query configuration and ETag context.\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.namespace.update` to change engine preferences.","inputSchema":{"additionalProperties":false,"properties":{"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"}},"type":"object"},"name":"lockd.namespace.get","outputSchema":{"additionalProperties":false,"properties":{"etag":{"type":"string"},"fallback_engine":{"type":"string"},"namespace":{"type":"string"},"preferred_engine":{"type":"string"}},"required":["namespace","preferred_engine","fallback_engine"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Namespace config changes are effective only after successful update; verify with lockd.namespace.get.\nPurpose: Update namespace query-engine configuration.\nUse when: You need to change preferred/fallback query engines for a namespace.\nRequires: `preferred_engine` and `fallback_engine` are required. `namespace` defaults to \"mcp\". Optional `if_match` enables CAS-safe updates.\nEffects: Persists namespace query config and returns updated values/ETag.\nRetry: Prefer `if_match` for deterministic retries; otherwise concurrent updates may overwrite each other.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> optionally call `lockd.index.flush` or rerun queries to validate behavior.","inputSchema":{"additionalProperties":false,"properties":{"fallback_engine":{"description":"Fallback query engine","type":"string"},"if_match":{"description":"Optional If-Match ETag for CAS updates","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"preferred_engine":{"description":"Preferred query engine","type":"string"}},"required":["preferred_engine","fallback_engine"],"type":"object"},"name":"lockd.namespace.update","outputSchema":{"additionalProperties":false,"properties":{"etag":{"type":"string"},"fallback_engine":{"type":"string"},"namespace":{"type":"string"},"preferred_engine":{"type":"string"}},"required":["namespace","preferred_engine","fallback_engine"],"type":"object"}},{"description":"Purpose: Run LQL queries over namespace data in key mode for memory retrieval and candidate discovery.\nUse when: You need to find relevant keys before reading or locking; preferred pattern is tags-first lookup with full-text fallback.\nRequires: `query` expression is required. `namespace` defaults to \"mcp\". Optional `limit`, `cursor`, `engine`, `refresh`, and `fields` refine execution. Query output is always keys. Common patterns: `in{field=/tags,any=planning|finance}`, `icontains{field=/...,value=contract}`, and `and.in{field=/tags,any=customer},and.icontains{field=/...,value=renewal}`.\nEffects: Returns matching keys plus pagination/index metadata (`cursor`, `index_seq`).\nRetry: Safe to retry. Cursor-based pagination should reuse the latest returned cursor.\nNext: Call `lockd.query.stream` for NDJSON document streaming, or `lockd.get`/`lockd.state.stream` for point reads. Keep tag vocabulary stable for high-recall memory retrieval.","inputSchema":{"additionalProperties":false,"properties":{"cursor":{"description":"Continuation cursor","type":"string"},"engine":{"description":"Optional query engine override: auto, index, or scan","type":"string"},"fields":{"additionalProperties":true,"description":"Optional query field projection map","type":"object"},"limit":{"description":"Maximum rows to return","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query":{"description":"LQL query expression","type":"string"},"refresh":{"description":"Optional refresh policy, for example wait_for","type":"string"}},"required":["query"],"type":"object"},"name":"lockd.query","outputSchema":{"additionalProperties":false,"properties":{"cursor":{"type":"string"},"index_seq":{"minimum":0,"type":"integer"},"keys":{"items":{"type":"string"},"type":["null","array"]},"metadata":{"additionalProperties":{"type":"string"},"type":"object"},"namespace":{"type":"string"}},"required":["namespace"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Run an LQL query and return a one-time NDJSON capability URL for document rows.\nUse when: You need query result documents (for example context/memory recall) without buffering them in MCP tool payloads.\nRequires: Active MCP session is required. `query` expression is required. `namespace` defaults to \"mcp\". Optional `limit`, `cursor`, `engine`, `refresh`, and `fields` refine execution. Recommended retrieval patterns mirror `lockd.query` (tags with `in` plus optional `icontains` full-text clauses).\nEffects: Returns query metadata plus one-time `download_url` that streams NDJSON rows (for example `{\"ns\":\"mcp\",\"key\":\"memory/customer-42\",\"ver\":17,\"doc\":{\"tags\":[\"customer\",\"renewal\"],\"status\":\"draft\"}}`) over HTTP GET.\nRetry: Safe to retry; each retry returns a new one-time URL. Do not reuse old URLs.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> fetch `download_url` with the returned method and continue with pagination cursor if needed.","inputSchema":{"additionalProperties":false,"properties":{"cursor":{"description":"Continuation cursor","type":"string"},"engine":{"description":"Optional query engine override: auto, index, or scan","type":"string"},"fields":{"additionalProperties":true,"description":"Optional query field projection map","type":"object"},"limit":{"description":"Maximum rows to return","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query":{"description":"LQL query expression","type":"string"},"refresh":{"description":"Optional refresh policy, for example wait_for","type":"string"}},"required":["query"],"type":"object"},"name":"lockd.query.stream","outputSchema":{"additionalProperties":false,"properties":{"cursor":{"type":"string"},"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"index_seq":{"minimum":0,"type":"integer"},"metadata":{"additionalProperties":{"type":"string"},"type":"object"},"namespace":{"type":"string"}},"required":["namespace","download_url","download_method","download_expires_at_unix"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nNON-IDEMPOTENT: Do not call this tool more than once per delivery attempt.\nPurpose: Acknowledge successful processing of a dequeued message.\nUse when: Worker completed handling of a leased message.\nRequires: `queue`, `message_id`, `lease_id`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Include `fencing_token` and any `state_*` fields exactly as returned by `lockd.queue.dequeue` for deterministic queue/state coordination. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Confirms processing and removes/commits message state according to lockd queue semantics.\nRetry: Do not replay ack blindly. After transport ambiguity, inspect message/lease state first; after any ack attempt, abandon that delivery attempt and dequeue again.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> dequeue next message or run follow-up updates.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Dequeued fencing token","type":"integer"},"lease_id":{"description":"Dequeued lease id","type":"string"},"message_id":{"description":"Dequeued message id","type":"string"},"meta_etag":{"description":"Dequeued meta etag","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name","type":"string"},"state_etag":{"description":"Optional state etag","type":"string"},"state_fencing_token":{"description":"Optional state fencing token","type":"integer"},"state_lease_id":{"description":"Optional state lease id","type":"string"},"txn_id":{"description":"Optional transaction id","type":"string"}},"required":["queue","message_id","lease_id","fencing_token","meta_etag"],"type":"object"},"name":"lockd.queue.ack","outputSchema":{"additionalProperties":false,"properties":{"acked":{"type":"boolean"},"correlation_id":{"type":"string"}},"required":["acked"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nNON-IDEMPOTENT: Do not call this tool more than once per delivery attempt.\nPurpose: Requeue a leased message intentionally without counting it as failure.\nUse when: Message is valid but should be processed later or by another worker.\nRequires: `queue`, `message_id`, `lease_id`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Include `fencing_token` and any `state_*` fields from dequeue. Optional `delay_seconds` postpones visibility. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Returns message to queue with defer intent and optional delay.\nRetry: Do not replay defer for the same delivery attempt. Repeated defer can alter visibility timing; on ambiguity, inspect state and continue with a new dequeue cycle.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue polling/subscription and dequeue again when ready.","inputSchema":{"additionalProperties":false,"properties":{"delay_seconds":{"description":"Visibility delay before message becomes available again","type":"integer"},"fencing_token":{"description":"Dequeued fencing token","type":"integer"},"lease_id":{"description":"Dequeued lease id","type":"string"},"message_id":{"description":"Dequeued message id","type":"string"},"meta_etag":{"description":"Dequeued meta etag","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name","type":"string"},"state_etag":{"description":"Optional state etag","type":"string"},"state_fencing_token":{"description":"Optional state fencing token","type":"integer"},"state_lease_id":{"description":"Optional state lease id","type":"string"},"txn_id":{"description":"Optional transaction id","type":"string"}},"required":["queue","message_id","lease_id","fencing_token","meta_etag"],"type":"object"},"name":"lockd.queue.defer","outputSchema":{"additionalProperties":false,"properties":{"correlation_id":{"type":"string"},"meta_etag":{"type":"string"},"requeued":{"type":"boolean"}},"required":["requeued"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Dequeue lease/message identifiers are operation-scoped; never replay stale values.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Receive one available message lease from a queue.\nUse when: A worker is ready to process the next queue item.\nRequires: `queue` defaults to \"lockd.agent.bus\". `namespace` defaults to \"mcp\". `owner` defaults to OAuth client id. Optional `stateful`, `visibility_seconds`, `cursor`, and `txn_id` tune dequeue behavior. `payload_mode` supports `auto` (default), `inline`, `stream`, `none`; `state_mode` (when `stateful=true`) supports the same values. For both modes, `auto` resolves inline when payload bytes <= `lockd.hint.inline_max_payload_bytes`, otherwise stream. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Returns `found=false` when no message is available, or lease metadata plus payload delivery according to `payload_mode` (inline fields or stream URL). For `stateful=true`, dequeue is all-or-nothing: state lease acquisition is required for success, and on contention/failure the call returns no leased message.\nRetry: Safe to retry polling, but each retry may lease a different message. Never reuse stale lease/message identifiers.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> process payload/state and then ack/nack/defer.","inputSchema":{"additionalProperties":false,"properties":{"block_seconds":{"description":"Long-poll wait; -1 no wait, 0 wait forever, >0 wait seconds","type":"integer"},"cursor":{"description":"Optional continuation cursor from previous dequeue response","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"owner":{"description":"Consumer owner ID (defaults to oauth client id)","type":"string"},"payload_mode":{"description":"Payload mode: auto (default), inline, stream, or none","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"},"state_mode":{"description":"State payload mode when stateful=true: auto, inline, stream, or none (default)","type":"string"},"stateful":{"description":"Acquire workflow state lease alongside dequeued message","type":"boolean"},"txn_id":{"description":"Optional transaction id to bind dequeue operations","type":"string"},"visibility_seconds":{"description":"Optional visibility timeout override in seconds","type":"integer"}},"type":"object"},"name":"lockd.queue.dequeue","outputSchema":{"additionalProperties":false,"properties":{"attempts":{"type":"integer"},"content_type":{"type":"string"},"correlation_id":{"type":"string"},"failure_attempts":{"type":"integer"},"fencing_token":{"type":"integer"},"found":{"type":"boolean"},"lease_expires_at_unix":{"type":"integer"},"lease_id":{"type":"string"},"max_attempts":{"type":"integer"},"message_id":{"type":"string"},"meta_etag":{"type":"string"},"namespace":{"type":"string"},"next_cursor":{"type":"string"},"not_visible_until_unix":{"type":"integer"},"payload_base64":{"type":"string"},"payload_bytes":{"type":"integer"},"payload_download_expires_at_unix":{"type":"integer"},"payload_download_method":{"type":"string"},"payload_download_url":{"type":"string"},"payload_mode":{"type":"string"},"payload_text":{"type":"string"},"queue":{"type":"string"},"state_download_expires_at_unix":{"type":"integer"},"state_download_method":{"type":"string"},"state_download_url":{"type":"string"},"state_etag":{"type":"string"},"state_fencing_token":{"type":"integer"},"state_found":{"type":"boolean"},"state_lease_expires_at_unix":{"type":"integer"},"state_lease_id":{"type":"string"},"state_payload_base64":{"type":"string"},"state_payload_bytes":{"type":"integer"},"state_payload_mode":{"type":"string"},"state_payload_text":{"type":"string"},"state_version":{"type":"integer"},"txn_id":{"type":"string"},"visibility_timeout_seconds":{"type":"integer"}},"required":["namespace","queue","found","payload_mode"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nPAYLOAD RULE: If payload size is unknown or may exceed limits, call lockd.hint and use stream workflow; do not guess.\nPurpose: Publish a message to a lockd queue for agent coordination.\nUse when: You need to signal work/events/context to queue consumers and payload fits inline limits.\nRequires: `queue` defaults to \"lockd.agent.bus\". `namespace` defaults to \"mcp\". Provide at most one of `payload_text` or `payload_base64`; decoded payload must be <= 2097152 bytes.\nEffects: Appends a queue message and returns delivery metadata (`message_id`, visibility, attempts). Queue ordering is best-effort under retries/requeues; do not assume strict FIFO across all consumers.\nRetry: Not idempotent. If retrying, assume duplicates are possible and rely on application dedupe keys.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- If payload may exceed inline limit -> call `lockd.queue.write_stream.begin` for large payloads.\n- Otherwise -> enqueue and continue with dequeue/ack/nack/defer workflows.","inputSchema":{"additionalProperties":false,"properties":{"attributes":{"additionalProperties":true,"description":"Message attributes metadata","type":"object"},"content_type":{"description":"Payload content type","type":"string"},"delay_seconds":{"description":"Initial invisibility delay","type":"integer"},"max_attempts":{"description":"Maximum failed attempts before terminal handling","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_base64":{"description":"Base64-encoded payload bytes","type":"string"},"payload_text":{"description":"UTF-8 payload text","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"},"ttl_seconds":{"description":"Message retention TTL in seconds","type":"integer"},"visibility_seconds":{"description":"Visibility timeout for dequeued lease","type":"integer"}},"type":"object"},"name":"lockd.queue.enqueue","outputSchema":{"additionalProperties":false,"properties":{"attempts":{"type":"integer"},"correlation_id":{"type":"string"},"failure_attempts":{"type":"integer"},"max_attempts":{"type":"integer"},"message_id":{"type":"string"},"namespace":{"type":"string"},"not_visible_until_unix":{"type":"integer"},"payload_bytes":{"type":"integer"},"queue":{"type":"string"},"visibility_timeout_seconds":{"type":"integer"}},"required":["namespace","queue","message_id","attempts","max_attempts","not_visible_until_unix","visibility_timeout_seconds","payload_bytes"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Dequeue lease/message identifiers are operation-scoped; never replay stale values.\nPurpose: Extend visibility/lease timeout for a currently leased queue message.\nUse when: Message processing is still active and lease timeout is approaching.\nRequires: `queue`, `message_id`, `lease_id`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Include `fencing_token` and optional state lease fields from dequeue for stateful workflows. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Refreshes message lease expiry and visibility timeout; returns updated lease timing and metadata ETag.\nRetry: Retry with the same identifiers only while lease remains valid. If lease may be expired or state mismatched, stop retrying and dequeue a new delivery attempt.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue processing and ack/nack/defer when complete.","inputSchema":{"additionalProperties":false,"properties":{"extend_by_seconds":{"description":"Lease extension in seconds","type":"integer"},"fencing_token":{"description":"Dequeued fencing token","type":"integer"},"lease_id":{"description":"Dequeued lease id","type":"string"},"message_id":{"description":"Dequeued message id","type":"string"},"meta_etag":{"description":"Dequeued meta etag","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name","type":"string"},"state_fencing_token":{"description":"Optional state fencing token","type":"integer"},"state_lease_id":{"description":"Optional state lease id","type":"string"},"txn_id":{"description":"Optional transaction id","type":"string"}},"required":["queue","message_id","lease_id","fencing_token","meta_etag"],"type":"object"},"name":"lockd.queue.extend","outputSchema":{"additionalProperties":false,"properties":{"correlation_id":{"type":"string"},"lease_expires_at_unix":{"type":"integer"},"meta_etag":{"type":"string"},"state_lease_expires_at_unix":{"type":"integer"},"visibility_timeout_seconds":{"type":"integer"}},"required":["lease_expires_at_unix","visibility_timeout_seconds"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nNON-IDEMPOTENT: Do not call this tool more than once per delivery attempt.\nPurpose: Requeue a message as a failure, consuming failure budget (`max_attempts`).\nUse when: Message processing failed and should be retried later with failure semantics.\nRequires: `queue`, `message_id`, `lease_id`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Include `fencing_token` and any `state_*` fields from dequeue. Optional `delay_seconds` and `reason` enrich retry behavior. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Requeues message with `intent=failure`, updates queue metadata ETag, and records optional failure detail.\nRetry: Do not replay nack for the same delivery attempt. Repeated nack can alter delay/attempt metadata; on ambiguity, inspect state and continue with a new dequeue cycle.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> dequeue next message or inspect retry/dead-letter behavior.","inputSchema":{"additionalProperties":false,"properties":{"delay_seconds":{"description":"Visibility delay before message becomes available again","type":"integer"},"fencing_token":{"description":"Dequeued fencing token","type":"integer"},"lease_id":{"description":"Dequeued lease id","type":"string"},"message_id":{"description":"Dequeued message id","type":"string"},"meta_etag":{"description":"Dequeued meta etag","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name","type":"string"},"reason":{"description":"Optional failure reason detail","type":"string"},"state_etag":{"description":"Optional state etag","type":"string"},"state_fencing_token":{"description":"Optional state fencing token","type":"integer"},"state_lease_id":{"description":"Optional state lease id","type":"string"},"txn_id":{"description":"Optional transaction id","type":"string"}},"required":["queue","message_id","lease_id","fencing_token","meta_etag"],"type":"object"},"name":"lockd.queue.nack","outputSchema":{"additionalProperties":false,"properties":{"correlation_id":{"type":"string"},"meta_etag":{"type":"string"},"requeued":{"type":"boolean"}},"required":["requeued"],"type":"object"}},{"description":"Purpose: Read side-effect-free queue runtime stats and current visible head snapshot.\nUse when: You need queue health/introspection signals before deciding whether to watch/dequeue.\nRequires: `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Returns dispatcher counters (`waiting_consumers`, `pending_candidates`, `total_consumers`), watcher state (`has_active_watcher`), and head availability fields when a visible message exists.\nRetry: Safe to retry; read-only operation.\nNext: Use `lockd.queue.watch` for bounded wakeups and `lockd.queue.dequeue` for actual message leasing/consumption.","inputSchema":{"additionalProperties":false,"properties":{"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"}},"type":"object"},"name":"lockd.queue.stats","outputSchema":{"additionalProperties":false,"properties":{"available":{"type":"boolean"},"correlation_id":{"type":"string"},"has_active_watcher":{"type":"boolean"},"head_age_seconds":{"type":"integer"},"head_enqueued_at_unix":{"type":"integer"},"head_message_id":{"type":"string"},"head_not_visible_until_unix":{"type":"integer"},"namespace":{"type":"string"},"pending_candidates":{"type":"integer"},"queue":{"type":"string"},"total_consumers":{"type":"integer"},"waiting_consumers":{"type":"integer"}},"required":["namespace","queue","waiting_consumers","pending_candidates","total_consumers","has_active_watcher","available"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Subscription state is session-scoped; treat subscriptions as gone when session ends.\nPurpose: Subscribe current MCP session to queue-availability notifications over SSE.\nUse when: You run a long-lived MCP runtime and want ongoing push wake-ups instead of pure dequeue polling.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Registers session subscription; future queue activity emits MCP progress notifications.\nRetry: Safe to retry; duplicate subscribe is handled as already subscribed.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> on notification, call `lockd.queue.dequeue` then `ack`/`nack`/`defer`.","inputSchema":{"additionalProperties":false,"properties":{"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"}},"type":"object"},"name":"lockd.queue.subscribe","outputSchema":{"additionalProperties":false,"properties":{"namespace":{"type":"string"},"queue":{"type":"string"},"subscribed":{"type":"boolean"}},"required":["namespace","queue","subscribed"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Subscription state is session-scoped; treat subscriptions as gone when session ends.\nPurpose: Remove current MCP session queue subscription.\nUse when: Worker no longer wants notifications for a queue.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Stops notification forwarding for the targeted session+queue binding.\nRetry: Safe to retry; unsubscribing an absent subscription returns false/unsubscribed state.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> either resubscribe later or continue with explicit dequeue polling.","inputSchema":{"additionalProperties":false,"properties":{"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"}},"type":"object"},"name":"lockd.queue.unsubscribe","outputSchema":{"additionalProperties":false,"properties":{"namespace":{"type":"string"},"queue":{"type":"string"},"unsubscribed":{"type":"boolean"}},"required":["namespace","queue","unsubscribed"],"type":"object"}},{"description":"Purpose: Wait for queue-availability events within a bounded call window.\nUse when: Interactive clients need push-like wakeups without maintaining long-lived subscriptions.\nRequires: `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\". Optional `duration_seconds` bounds wait time (default 30). Optional `max_events` bounds result size (default 1).\nEffects: Streams watch events from upstream lockd and returns a bounded event list with `stop_reason` (`max_events`, `timeout`, or `context_canceled`).\nRetry: Safe to retry; each invocation is independent and bounded.\nNext: After any event, call `lockd.queue.dequeue` and then `ack`/`nack`/`defer`.","inputSchema":{"additionalProperties":false,"properties":{"duration_seconds":{"description":"Maximum watch duration in seconds (default: 30)","type":"integer"},"max_events":{"description":"Maximum events to return before stopping (default: 1)","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"}},"type":"object"},"name":"lockd.queue.watch","outputSchema":{"additionalProperties":false,"properties":{"event_count":{"type":"integer"},"events":{"items":{"additionalProperties":false,"properties":{"available":{"type":"boolean"},"changed_at_unix":{"type":"integer"},"correlation_id":{"type":"string"},"head_message_id":{"type":"string"},"namespace":{"type":"string"},"queue":{"type":"string"}},"required":["namespace","queue","available"],"type":"object"},"type":["null","array"]},"namespace":{"type":"string"},"queue":{"type":"string"},"stop_reason":{"type":"string"}},"required":["namespace","queue","events","event_count","stop_reason"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit/abort attempt (success or failure), abandon this identifier and never reuse it.\nPurpose: Abort an in-flight queue write stream.\nUse when: Queued payload upload should be canceled.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates upload flow and frees stream resources.\nRetry: Safe to retry for cleanup, but do not assume abort reopens or reuses the stream; create a new stream for any retry path.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> begin a new queue stream if publish should be retried.","inputSchema":{"additionalProperties":false,"properties":{"reason":{"description":"Optional abort reason for diagnostics","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.queue.write_stream.abort","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"stream_id":{"type":"string"}},"required":["stream_id","aborted","bytes_received"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Open a session-scoped streaming queue publisher.\nUse when: Queue payload is too large for inline enqueue or you need bounded-memory uploads.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\". Delay/visibility/ttl/attributes/content_type options match `lockd.queue.enqueue`.\nEffects: Creates a stream session and returns `stream_id` plus one-time `upload_url` for direct HTTP PUT upload.\nRetry: Do not retry as idempotent. Begin creates a new stream each call; do not reuse identifiers from previous attempts.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> upload to `upload_url`, then status/commit or abort.","inputSchema":{"additionalProperties":false,"properties":{"attributes":{"additionalProperties":true,"description":"Message attributes metadata","type":"object"},"content_type":{"description":"Payload content type","type":"string"},"delay_seconds":{"description":"Initial invisibility delay","type":"integer"},"max_attempts":{"description":"Maximum failed attempts before terminal handling","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"},"ttl_seconds":{"description":"Message retention TTL in seconds","type":"integer"},"visibility_seconds":{"description":"Visibility timeout for dequeued lease","type":"integer"}},"type":"object"},"name":"lockd.queue.write_stream.begin","outputSchema":{"additionalProperties":false,"properties":{"stream_id":{"type":"string"},"upload_expires_at_unix":{"type":"integer"},"upload_method":{"type":"string"},"upload_url":{"type":"string"}},"required":["stream_id"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit/abort attempt (success or failure), abandon this identifier and never reuse it.\nPurpose: Finalize a queue write stream and publish the message.\nUse when: All payload chunks for a queued message have been appended.\nRequires: Active MCP session and `stream_id` are required. Optional `expected_bytes` and `expected_sha256` enforce upload integrity before commit.\nEffects: Closes upload stream, validates optional expectations, waits for upstream enqueue completion, and returns enqueue metadata.\nRetry: After any commit attempt (success or failure), do not retry with the same `stream_id`. Start a new begin→upload→commit sequence.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue with dequeue/ack workflows.","inputSchema":{"additionalProperties":false,"properties":{"expected_bytes":{"description":"Optional expected plaintext byte count of uploaded data","type":["null","integer"]},"expected_sha256":{"description":"Optional expected lowercase hex SHA-256 of uploaded plaintext bytes","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.queue.write_stream.commit","outputSchema":{"additionalProperties":false,"properties":{"attempts":{"type":"integer"},"bytes_received":{"type":"integer"},"correlation_id":{"type":"string"},"failure_attempts":{"type":"integer"},"max_attempts":{"type":"integer"},"message_id":{"type":"string"},"namespace":{"type":"string"},"not_visible_until_unix":{"type":"integer"},"payload_bytes":{"type":"integer"},"queue":{"type":"string"},"stream_id":{"type":"string"},"visibility_timeout_seconds":{"type":"integer"}},"required":["stream_id","bytes_received","namespace","queue","message_id","attempts","max_attempts","not_visible_until_unix","visibility_timeout_seconds","payload_bytes"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Use only the current active identifier; never continue workflows with stale identifiers.\nPurpose: Inspect in-flight queue write-stream upload progress.\nUse when: You need upload observability before publish commit.\nRequires: Active MCP session and `stream_id` are required.\nEffects: Returns `bytes_received`, computed `payload_sha256`, upload-capability availability/expiry, and commit-readiness flags.\nRetry: Safe to retry while stream exists.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> if `can_commit=true`, call `lockd.queue.write_stream.commit`; otherwise finish upload or abort.","inputSchema":{"additionalProperties":false,"properties":{"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.queue.write_stream.status","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"can_commit":{"type":"boolean"},"committing":{"type":"boolean"},"payload_sha256":{"type":"string"},"stream_id":{"type":"string"},"upload_capability_available":{"type":"boolean"},"upload_completed":{"type":"boolean"},"upload_expires_at_unix":{"type":"integer"},"upload_in_progress":{"type":"boolean"}},"required":["stream_id","bytes_received","upload_capability_available","upload_completed","upload_in_progress","committing","aborted","can_commit"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Update state metadata without replacing JSON state payload.\nUse when: Only metadata (for example `query_hidden`) needs to change.\nRequires: `key`, `lease_id`, and `query_hidden` are required. `namespace` defaults to \"mcp\". Optional CAS/fencing fields protect against races. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Persists metadata mutation and returns resulting version/metadata.\nRetry: Use CAS/fencing fields for deterministic retries; otherwise last-writer-wins behavior applies.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue updates or release the lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query_hidden":{"description":"Set true to hide, false to expose in queries","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","query_hidden"],"type":"object"},"name":"lockd.state.metadata","outputSchema":{"additionalProperties":false,"properties":{"query_hidden":{"type":["null","boolean"]},"version":{"type":"integer"}},"required":["version"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Apply LQL mutations to existing JSON state under lease protection without round-tripping payload bytes through MCP.\nUse when: You need server-side structured updates and want bounded-memory mutation execution, including incremental tag maintenance on existing documents.\nRequires: `key`, `lease_id`, and at least one `mutations` expression are required. `namespace` defaults to \"mcp\". Optional CAS/fencing fields (`if_etag`, `if_version`, `fencing_token`) are supported. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Loads lease-visible state, applies LQL mutations server-side, and writes updated state. Returns new version/ETag metadata.\nRetry: Use CAS/fencing fields for deterministic retries. Without guards, retries can reapply logical mutations.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> inspect results and then `lockd.lock.release` to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"mutations":{"description":"LQL mutation expressions","items":{"type":"string"},"type":["null","array"]},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query_hidden":{"description":"Optional query-hidden metadata mutation","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","mutations"],"type":"object"},"name":"lockd.state.mutate","outputSchema":{"additionalProperties":false,"properties":{"bytes":{"type":"integer"},"new_state_etag":{"type":"string"},"new_version":{"type":"integer"},"query_hidden":{"type":["null","boolean"]}},"required":["new_version","new_state_etag","bytes"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Apply an RFC 7396 JSON merge patch to current state under lease protection.\nUse when: You need partial updates without sending a full replacement document.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Provide exactly one of `patch_text` or `patch_base64` and keep patch/result within inline limits; use `state.write_stream` for large documents. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Loads current state (lease-bound read), applies merge patch, then writes updated state and returns new version/ETag metadata.\nRetry: Use `if_etag`, `if_version`, and `fencing_token` for safe retries. Patch retries without guards can duplicate logical effects.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- If payload may exceed inline limit -> call `lockd.state.write_stream.begin` if patched result may exceed inline limits.\n- Otherwise -> verify result and then `lockd.lock.release` to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"patch_base64":{"description":"Base64-encoded JSON merge patch document","type":"string"},"patch_text":{"description":"UTF-8 JSON merge patch document","type":"string"},"query_hidden":{"description":"Optional query-hidden metadata mutation","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.state.patch","outputSchema":{"additionalProperties":false,"properties":{"bytes":{"type":"integer"},"new_state_etag":{"type":"string"},"new_version":{"type":"integer"},"query_hidden":{"type":["null","boolean"]}},"required":["new_version","new_state_etag","bytes"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Delete state for a key under lease protection.\nUse when: State should be removed as part of cleanup or workflow transitions.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` and CAS/fencing fields support XA/concurrency control. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Removes committed state for the key (or stages delete in transaction context).\nRetry: Prefer CAS/fencing guards. If retrying after unknown outcome, verify current state/version first; do not assume delete status.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> release lease to finalize, or write replacement state/attachments first.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.state.remove","outputSchema":{"additionalProperties":false,"properties":{"new_version":{"type":"integer"},"removed":{"type":"boolean"}},"required":["removed"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Create a one-time download capability URL for state payload bytes.\nUse when: You need state content (small or large) without routing payload through MCP tool responses.\nRequires: Active MCP session is required. `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true; set `public=false` with `lease_id` for lease-bound reads.\nEffects: Returns metadata plus one-time `download_url` and `download_method` for direct HTTP download.\nRetry: Safe to retry; each retry returns a new one-time URL. Do not reuse old URLs.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> fetch `download_url` directly and continue lock/query workflow.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease ID required when public=false","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]}},"required":["key"],"type":"object"},"name":"lockd.state.stream","outputSchema":{"additionalProperties":false,"properties":{"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"etag":{"type":"string"},"found":{"type":"boolean"},"key":{"type":"string"},"namespace":{"type":"string"},"version":{"type":"integer"}},"required":["namespace","key","found"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Write JSON state under lease protection.\nUse when: You need to create or update state for a locked key and payload fits inline request limits. Unless caller policy says otherwise, include a top-level `tags` JSON array for future `in` selector retrieval. No fixed schema fields are required beyond `tags`.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Provide at most one of `payload_text` or `payload_base64`; when both are omitted payload defaults to `{}`. Decoded payload must be <= 2097152 bytes. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Updates state and returns new version/ETag metadata; can also mutate `query_hidden` metadata. Suggested memory shape keeps your existing fields and adds tags, for example `{\"tags\":[\"planning\",\"q3\"],\"status\":\"draft\"}` for fast `in{field=/tags,any=planning|q3}` queries.\nRetry: Use `if_etag`, `if_version`, and `fencing_token` for safe retries. Without guards, retries can apply duplicate writes.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- If payload may exceed inline limit -> call `lockd.state.write_stream.begin` for large payload uploads.\n- Otherwise -> write state and then `lockd.lock.release` to commit or rollback.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_base64":{"description":"Base64-encoded JSON payload bytes","type":"string"},"payload_text":{"description":"UTF-8 JSON payload text","type":"string"},"query_hidden":{"description":"Optional query-hidden metadata mutation","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.state.update","outputSchema":{"additionalProperties":false,"properties":{"bytes":{"type":"integer"},"new_state_etag":{"type":"string"},"new_version":{"type":"integer"},"query_hidden":{"type":["null","boolean"]}},"required":["new_version","new_state_etag","bytes"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit/abort attempt (success or failure), abandon this identifier and never reuse it.\nPurpose: Abort an in-flight state write stream.\nUse when: Upload should be canceled or discarded before commit.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates the stream, cancels upstream request flow, and frees stream resources.\nRetry: Safe to retry for cleanup, but do not assume abort reopens or reuses the stream; create a new stream for any retry path.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> begin a new stream if upload should be retried.","inputSchema":{"additionalProperties":false,"properties":{"reason":{"description":"Optional abort reason for diagnostics","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.state.write_stream.abort","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"stream_id":{"type":"string"}},"required":["stream_id","aborted","bytes_received"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Open a session-scoped streaming state writer.\nUse when: State payload is too large for inline JSON or you want bounded-memory uploads.\nRequires: Active MCP session is required. `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional CAS/fencing fields mirror `lockd.state.update`.\nEffects: Creates a stream session and returns `stream_id` plus one-time `upload_url` for direct HTTP PUT upload outside MCP tool payload context.\nRetry: Do not retry as idempotent. Begin creates a new stream each call; do not reuse identifiers from previous attempts.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> upload bytes to `upload_url`, then status/commit or abort.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query_hidden":{"description":"Optional query-hidden metadata mutation","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.state.write_stream.begin","outputSchema":{"additionalProperties":false,"properties":{"stream_id":{"type":"string"},"upload_expires_at_unix":{"type":"integer"},"upload_method":{"type":"string"},"upload_url":{"type":"string"}},"required":["stream_id"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit attempt (success or failure), abandon this identifier; durability still depends on successful lock release.\nPurpose: Finalize a state write stream and commit it to upstream lockd.\nUse when: All payload chunks have been appended.\nRequires: Active MCP session and `stream_id` are required. Optional `expected_bytes` and `expected_sha256` enforce upload integrity before commit.\nEffects: Closes the upload stream, validates optional expectations, waits for upstream completion, and returns state update result metadata. State remains staged under the lease until `lockd.lock.release` commits (or `rollback=true` discards).\nRetry: After any commit attempt (success or failure), do not retry with the same `stream_id`. Start a new begin→upload→commit sequence.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> call `lockd.lock.release` to finalize durability (or continue staged mutations first).","inputSchema":{"additionalProperties":false,"properties":{"expected_bytes":{"description":"Optional expected plaintext byte count of uploaded data","type":["null","integer"]},"expected_sha256":{"description":"Optional expected lowercase hex SHA-256 of uploaded plaintext bytes","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.state.write_stream.commit","outputSchema":{"additionalProperties":false,"properties":{"bytes":{"type":"integer"},"bytes_received":{"type":"integer"},"new_state_etag":{"type":"string"},"new_version":{"type":"integer"},"query_hidden":{"type":["null","boolean"]},"stream_id":{"type":"string"}},"required":["stream_id","bytes_received","new_version","new_state_etag","bytes"],"type":"object"}},{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Use only the current active identifier; never continue workflows with stale identifiers.\nPurpose: Inspect in-flight state write-stream upload progress.\nUse when: You need upload observability before commit (for example after external HTTP upload attempts).\nRequires: Active MCP session and `stream_id` are required.\nEffects: Returns `bytes_received`, computed `payload_sha256`, upload-capability availability/expiry, and commit-readiness flags.\nRetry: Safe to retry while stream exists.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> if `can_commit=true`, call `lockd.state.write_stream.commit`; otherwise finish upload or `abort` and restart.","inputSchema":{"additionalProperties":false,"properties":{"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.state.write_stream.status","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"can_commit":{"type":"boolean"},"committing":{"type":"boolean"},"payload_sha256":{"type":"string"},"stream_id":{"type":"string"},"upload_capability_available":{"type":"boolean"},"upload_completed":{"type":"boolean"},"upload_expires_at_unix":{"type":"integer"},"upload_in_progress":{"type":"boolean"}},"required":["stream_id","bytes_received","upload_capability_available","upload_completed","upload_in_progress","committing","aborted","can_commit"],"type":"object"}}]}}
{"kind":"initialize","data":{"capabilities":{"logging":{},"resources":{"listChanged":true},"tools":{"listChanged":true}},"instructions":"lockd MCP facade operating manual:\n- Default namespace: mcp\n- Default coordination queue: lockd.agent.bus\n- Discovery workflow: call lockd.hint first to learn namespace-access hints and inline payload limits, then lockd.help for workflows (use topic=lql for complete selector syntax).\n- Queue workflow: dequeue -> ack | nack(failure) | defer(intentional). Use queue.extend for long-running handlers.\n- Queue introspection: use lockd.queue.stats for side-effect-free queue availability and dispatcher counters.\n- Queue pagination: dequeue returns `next_cursor`; pass it back as `cursor` when continuing scans.\n- Bounded watch workflow: use lockd.queue.watch for interactive polling-compatible wakeups.\n- Subscription workflow: lockd.queue.subscribe for long-lived runtimes that can hold session-level SSE subscriptions.\n- XA workflow: optional txn_id can be attached to lock/queue/state/attachment operations; transaction decisions are applied by lockd APIs, not TC decision tools in this MCP surface.\n- Lock safety: keep lease IDs/fencing tokens from lock operations and send them back on protected writes.\n- Write safety: inline payloads are capped by mcp.inline_max_bytes. For payload_mode/state_mode auto, payloads <= lockd.hint.inline_max_payload_bytes are inline and larger payloads switch to stream.\n- Stream workflow: use write_stream begin + upload_url + optional write_stream.status + commit for larger writes (state, queue, attachments). Commit accepts optional expected_bytes/expected_sha256.\n- Transfer URL hygiene: capability URLs are bearer-style secrets; avoid shell history/process-list leakage and avoid pasting capability URLs into chat/tickets.\n- Partial mutation: use lockd.state.mutate for LQL expression-based updates and lockd.state.patch for RFC 7396 merge patch updates.\n- Query first when uncertain: use lockd.query for key discovery, lockd.query.stream for NDJSON document stream URLs, and lockd.state.stream / lockd.attachments.stream for point payload reads.\n- Memory tagging convention: unless a workflow says otherwise, store a top-level `tags` JSON array on saved objects and query tags with `in{field=/tags,any=planning|finance}`.\n- Schema guidance: no fixed schema fields are required beyond `tags`; preserve caller-defined fields.\n- Full-text retrieval: use `icontains{field=/...,value=contract}` for broad recall and combine with tag filters for precision.\n- Documentation resources: resource://docs/overview.md, resource://docs/locks.md, resource://docs/messaging.md, resource://docs/agent-sync.md, resource://docs/lql.md","protocolVersion":"2025-06-18","serverInfo":{"name":"lockd-mcp-facade","version":"0.1.0"}}}
{"kind":"instructions","name":"initialize.instructions","data":"lockd MCP facade operating manual:\n- Default namespace: mcp\n- Default coordination queue: lockd.agent.bus\n- Discovery workflow: call lockd.hint first to learn namespace-access hints and inline payload limits, then lockd.help for workflows (use topic=lql for complete selector syntax).\n- Queue workflow: dequeue -> ack | nack(failure) | defer(intentional). Use queue.extend for long-running handlers.\n- Queue introspection: use lockd.queue.stats for side-effect-free queue availability and dispatcher counters.\n- Queue pagination: dequeue returns `next_cursor`; pass it back as `cursor` when continuing scans.\n- Bounded watch workflow: use lockd.queue.watch for interactive polling-compatible wakeups.\n- Subscription workflow: lockd.queue.subscribe for long-lived runtimes that can hold session-level SSE subscriptions.\n- XA workflow: optional txn_id can be attached to lock/queue/state/attachment operations; transaction decisions are applied by lockd APIs, not TC decision tools in this MCP surface.\n- Lock safety: keep lease IDs/fencing tokens from lock operations and send them back on protected writes.\n- Write safety: inline payloads are capped by mcp.inline_max_bytes. For payload_mode/state_mode auto, payloads <= lockd.hint.inline_max_payload_bytes are inline and larger payloads switch to stream.\n- Stream workflow: use write_stream begin + upload_url + optional write_stream.status + commit for larger writes (state, queue, attachments). Commit accepts optional expected_bytes/expected_sha256.\n- Transfer URL hygiene: capability URLs are bearer-style secrets; avoid shell history/process-list leakage and avoid pasting capability URLs into chat/tickets.\n- Partial mutation: use lockd.state.mutate for LQL expression-based updates and lockd.state.patch for RFC 7396 merge patch updates.\n- Query first when uncertain: use lockd.query for key discovery, lockd.query.stream for NDJSON document stream URLs, and lockd.state.stream / lockd.attachments.stream for point payload reads.\n- Memory tagging convention: unless a workflow says otherwise, store a top-level `tags` JSON array on saved objects and query tags with `in{field=/tags,any=planning|finance}`.\n- Schema guidance: no fixed schema fields are required beyond `tags`; preserve caller-defined fields.\n- Full-text retrieval: use `icontains{field=/...,value=contract}` for broad recall and combine with tag filters for precision.\n- Documentation resources: resource://docs/overview.md, resource://docs/locks.md, resource://docs/messaging.md, resource://docs/agent-sync.md, resource://docs/lql.md"}
{"kind":"instructions","name":"server.default","data":"lockd MCP facade operating manual:\n- Default namespace: mcp\n- Default coordination queue: lockd.agent.bus\n- Discovery workflow: call lockd.hint first to learn namespace-access hints and inline payload limits, then lockd.help for workflows (use topic=lql for complete selector syntax).\n- Queue workflow: dequeue -> ack | nack(failure) | defer(intentional). Use queue.extend for long-running handlers.\n- Queue introspection: use lockd.queue.stats for side-effect-free queue availability and dispatcher counters.\n- Queue pagination: dequeue returns `next_cursor`; pass it back as `cursor` when continuing scans.\n- Bounded watch workflow: use lockd.queue.watch for interactive polling-compatible wakeups.\n- Subscription workflow: lockd.queue.subscribe for long-lived runtimes that can hold session-level SSE subscriptions.\n- XA workflow: optional txn_id can be attached to lock/queue/state/attachment operations; transaction decisions are applied by lockd APIs, not TC decision tools in this MCP surface.\n- Lock safety: keep lease IDs/fencing tokens from lock operations and send them back on protected writes.\n- Write safety: inline payloads are capped by mcp.inline_max_bytes. For payload_mode/state_mode auto, payloads <= lockd.hint.inline_max_payload_bytes are inline and larger payloads switch to stream.\n- Stream workflow: use write_stream begin + upload_url + optional write_stream.status + commit for larger writes (state, queue, attachments). Commit accepts optional expected_bytes/expected_sha256.\n- Transfer URL hygiene: capability URLs are bearer-style secrets; avoid shell history/process-list leakage and avoid pasting capability URLs into chat/tickets.\n- Partial mutation: use lockd.state.mutate for LQL expression-based updates and lockd.state.patch for RFC 7396 merge patch updates.\n- Query first when uncertain: use lockd.query for key discovery, lockd.query.stream for NDJSON document stream URLs, and lockd.state.stream / lockd.attachments.stream for point payload reads.\n- Memory tagging convention: unless a workflow says otherwise, store a top-level `tags` JSON array on saved objects and query tags with `in{field=/tags,any=planning|finance}`.\n- Schema guidance: no fixed schema fields are required beyond `tags`; preserve caller-defined fields.\n- Full-text retrieval: use `icontains{field=/...,value=contract}` for broad recall and combine with tag filters for precision.\n- Documentation resources: resource://docs/overview.md, resource://docs/locks.md, resource://docs/messaging.md, resource://docs/agent-sync.md, resource://docs/lql.md"}
{"kind":"tool","name":"lockd.attachments.checksum","data":{"description":"Purpose: Return persisted plaintext SHA-256 checksum for one attachment without reading attachment payload.\nUse when: You need integrity metadata quickly and cannot afford a full payload read.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required.\nEffects: Returns metadata-derived `plaintext_sha256` for the selected attachment.\nRetry: Safe to retry; this is a read operation.\nNext: Compare against client-side checksum after `lockd.attachments.stream` if payload verification is needed.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.checksum","outputSchema":{"additionalProperties":false,"properties":{"attachment_id":{"type":"string"},"attachment_name":{"type":"string"},"key":{"type":"string"},"namespace":{"type":"string"},"plaintext_sha256":{"type":"string"}},"required":["namespace","key","attachment_id","attachment_name"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.delete","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Delete a single attachment under lease protection.\nUse when: One attachment should be removed while keeping others.\nRequires: `key` and `lease_id` are required, plus either `id` or `name`. `namespace` defaults to \"mcp\". Optional `txn_id` enables XA staging. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Deletes (or stages deletion of) the targeted attachment and returns success state.\nRetry: If retrying after unknown outcome, verify attachment state first; do not assume delete status.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> verify remaining attachments and release lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.attachments.delete","outputSchema":{"additionalProperties":false,"properties":{"deleted":{"type":"boolean"},"version":{"type":"integer"}},"required":["deleted","version"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.delete_all","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Delete all attachments for a key under lease protection.\nUse when: You need full attachment cleanup for a key.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` allows transactional staging. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Removes (or stages removal of) all attachments for the key.\nRetry: If retrying after unknown outcome, verify attachment list first; do not assume delete-all status.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> optionally write replacements and release lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.attachments.delete_all","outputSchema":{"additionalProperties":false,"properties":{"deleted":{"type":"integer"},"version":{"type":"integer"}},"required":["deleted","version"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.get","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Resolve one attachment by id or name and return metadata plus optional inline/stream payload delivery.\nUse when: You need attachment payload in either inline or streaming mode.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true; if `public=false`, `lease_id` is required and if `public=true`, `lease_id` must be omitted. `payload_mode` supports `auto` (default), `inline`, `stream`, or `none`; `auto` resolves to inline when payload bytes <= `lockd.hint.inline_max_payload_bytes`, otherwise stream.\nEffects: Returns attachment metadata/checksum and either inline payload (`payload_text` or `payload_base64`) or one-time stream URL.\nRetry: Safe to retry; this is a read operation.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> use `lockd.attachments.stream` for explicit streaming-only access and checksum for integrity checks.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_mode":{"description":"Payload mode: auto (default), inline, stream, or none","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.get","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"key":{"type":"string"},"namespace":{"type":"string"},"payload_base64":{"type":"string"},"payload_bytes":{"type":"integer"},"payload_mode":{"type":"string"},"payload_sha256":{"type":"string"},"payload_text":{"type":"string"}},"required":["namespace","key","attachment","payload_mode","payload_bytes"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.head","data":{"description":"Purpose: Fetch metadata for one attachment by id or name without reading payload bytes.\nUse when: You need to inspect attachment existence/size/type before deciding whether to download content.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. If `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata only (`id`, `name`, `size`, `plaintext_sha256`, timestamps, and content type).\nRetry: Safe to retry; this is a read operation.\nNext: Call `lockd.attachments.stream` when payload content is required.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.head","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"key":{"type":"string"},"namespace":{"type":"string"}},"required":["namespace","key","attachment"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.list","data":{"description":"Purpose: List attachment metadata for a key.\nUse when: You need attachment ids/names before get/delete workflows.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. If `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata only (no payload bytes).\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.attachments.head` for metadata-only lookup, `lockd.attachments.get` for payload access, or delete tools for cleanup.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.list","outputSchema":{"additionalProperties":false,"properties":{"attachments":{"items":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"type":["null","array"]},"key":{"type":"string"},"namespace":{"type":"string"}},"required":["namespace","key","attachments"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.put","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nPAYLOAD RULE: If payload size is unknown or may exceed limits, call lockd.hint and use stream workflow; do not guess.\nPurpose: Write attachment payload inline under lease protection.\nUse when: Attachment payload fits inline limits and you want a single MCP tool call write.\nRequires: `key`, `lease_id`, and `name` are required. `namespace` defaults to \"mcp\". Provide at most one of `payload_text` or `payload_base64`; decoded payload must be <= 2097152 bytes. `mode` supports `create` (default), `upsert`, `replace`. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Writes attachment bytes and returns attachment metadata/version.\nRetry: Retry only with explicit `mode`/fencing intent. Do not assume previous attempt failed; verify attachment state before replay.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- If payload may exceed inline limit -> call `lockd.attachments.write_stream.begin` for large attachment uploads.\n- Otherwise -> write attachment, then release lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"content_type":{"description":"Attachment content type","type":"string"},"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"max_bytes":{"description":"Optional upload size cap","type":"integer"},"mode":{"description":"Write mode: create (default), upsert, or replace","type":"string"},"name":{"description":"Attachment name","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_base64":{"description":"Base64-encoded payload bytes","type":"string"},"payload_text":{"description":"UTF-8 payload text","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","name"],"type":"object"},"name":"lockd.attachments.put","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"noop":{"type":"boolean"},"version":{"type":"integer"}},"required":["attachment","noop","version"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.stream","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Create a one-time download capability URL for attachment payload bytes.\nUse when: You need attachment content without pushing payload through MCP tool responses.\nRequires: Active MCP session is required. `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true; if `public=false`, `lease_id` is required and if `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata plus one-time `download_url` and `download_method` for direct HTTP download.\nRetry: Safe to retry; each retry returns a new one-time URL. Do not reuse old URLs.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> fetch `download_url` directly and compare with checksum when integrity checks are needed.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"id":{"description":"Attachment id selector","type":"string"},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease id required when public=false","type":"string"},"name":{"description":"Attachment name selector","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.attachments.stream","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"key":{"type":"string"},"namespace":{"type":"string"}},"required":["namespace","key","attachment"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.write_stream.abort","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit/abort attempt (success or failure), abandon this identifier and never reuse it.\nPurpose: Abort an in-flight attachment write stream.\nUse when: Attachment upload should be canceled.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates upload flow and frees stream resources.\nRetry: Safe to retry for cleanup, but do not assume abort reopens or reuses the stream; create a new stream for any retry path.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> begin a new attachment stream if upload should be retried.","inputSchema":{"additionalProperties":false,"properties":{"reason":{"description":"Optional abort reason for diagnostics","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.attachments.write_stream.abort","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"stream_id":{"type":"string"}},"required":["stream_id","aborted","bytes_received"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.write_stream.begin","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Open a session-scoped streaming attachment writer.\nUse when: Attachment payload is larger than inline limit or you want streaming upload semantics.\nRequires: Active MCP session is required. `key`, `lease_id`, and `name` are required. `namespace` defaults to \"mcp\". `mode` supports `create` (default), `upsert`, `replace`.\nEffects: Creates a stream session and returns one-time `upload_url` for direct HTTP PUT upload into upstream attachment flow.\nRetry: Do not retry as idempotent. Begin creates a new stream each call; do not reuse identifiers from previous attempts.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> upload to `upload_url`, then status/commit or abort.","inputSchema":{"additionalProperties":false,"properties":{"content_type":{"description":"Attachment content type","type":"string"},"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"max_bytes":{"description":"Optional upload size cap","type":"integer"},"mode":{"description":"Write mode: create (default), upsert, or replace","type":"string"},"name":{"description":"Attachment name","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","name"],"type":"object"},"name":"lockd.attachments.write_stream.begin","outputSchema":{"additionalProperties":false,"properties":{"stream_id":{"type":"string"},"upload_expires_at_unix":{"type":"integer"},"upload_method":{"type":"string"},"upload_url":{"type":"string"}},"required":["stream_id"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.write_stream.commit","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit attempt (success or failure), abandon this identifier; durability still depends on successful lock release.\nPurpose: Finalize an attachment write stream.\nUse when: All attachment payload chunks have been appended.\nRequires: Active MCP session and `stream_id` are required. Optional `expected_bytes` and `expected_sha256` enforce upload integrity before commit.\nEffects: Closes the upload stream, validates optional expectations, waits for upstream attach completion, and returns attachment metadata/version. Attachment changes stay staged under the lease until `lockd.lock.release` commits (or rollback discards).\nRetry: After any commit attempt (success or failure), do not retry with the same `stream_id`. Start a new begin→upload→commit sequence.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> verify attachment metadata and release lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"expected_bytes":{"description":"Optional expected plaintext byte count of uploaded data","type":["null","integer"]},"expected_sha256":{"description":"Optional expected lowercase hex SHA-256 of uploaded plaintext bytes","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.attachments.write_stream.commit","outputSchema":{"additionalProperties":false,"properties":{"attachment":{"additionalProperties":false,"properties":{"content_type":{"type":"string"},"created_at_unix":{"type":"integer"},"id":{"type":"string"},"name":{"type":"string"},"plaintext_sha256":{"type":"string"},"size":{"type":"integer"},"updated_at_unix":{"type":"integer"}},"required":["id","name","size"],"type":"object"},"bytes_received":{"type":"integer"},"noop":{"type":"boolean"},"stream_id":{"type":"string"},"version":{"type":"integer"}},"required":["stream_id","bytes_received","attachment","noop","version"],"type":"object"}}}
{"kind":"tool","name":"lockd.attachments.write_stream.status","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Use only the current active identifier; never continue workflows with stale identifiers.\nPurpose: Inspect in-flight attachment write-stream upload progress.\nUse when: You need upload observability before attachment commit.\nRequires: Active MCP session and `stream_id` are required.\nEffects: Returns `bytes_received`, computed `payload_sha256`, upload-capability availability/expiry, and commit-readiness flags.\nRetry: Safe to retry while stream exists.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> if `can_commit=true`, call `lockd.attachments.write_stream.commit`; otherwise finish upload or abort.","inputSchema":{"additionalProperties":false,"properties":{"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.attachments.write_stream.status","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"can_commit":{"type":"boolean"},"committing":{"type":"boolean"},"payload_sha256":{"type":"string"},"stream_id":{"type":"string"},"upload_capability_available":{"type":"boolean"},"upload_completed":{"type":"boolean"},"upload_expires_at_unix":{"type":"integer"},"upload_in_progress":{"type":"boolean"}},"required":["stream_id","bytes_received","upload_capability_available","upload_completed","upload_in_progress","committing","aborted","can_commit"],"type":"object"}}}
{"kind":"tool","name":"lockd.describe","data":{"description":"Purpose: Read key metadata (lease owner, version, ETag, timestamps) without returning state payload.\nUse when: You need lock/version metadata for diagnostics, conflict handling, or coordination checks.\nRequires: `key` is required. `namespace` defaults to \"mcp\" when omitted.\nEffects: Returns metadata snapshot only; does not mutate state.\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.get` to read payload or lock tools for mutation workflows.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"Lock key to inspect","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.describe","outputSchema":{"additionalProperties":false,"properties":{"expires_at_unix":{"type":"integer"},"key":{"type":"string"},"lease_id":{"type":"string"},"namespace":{"type":"string"},"owner":{"type":"string"},"query_hidden":{"type":["null","boolean"]},"state_etag":{"type":"string"},"updated_at_unix":{"type":"integer"},"version":{"type":"integer"}},"required":["namespace","key","version"],"type":"object"}}}
{"kind":"tool","name":"lockd.get","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Read committed JSON state for one key.\nUse when: You need key metadata and optionally payload bytes in inline or streaming mode.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. `payload_mode` supports `auto` (default), `inline`, `stream`, or `none`; `auto` resolves to inline when payload bytes <= `lockd.hint.inline_max_payload_bytes`, otherwise stream.\nEffects: Returns metadata plus either inline payload (`payload_text` or `payload_base64`) or one-time stream download URL, depending on `payload_mode` and payload size.\nRetry: Safe to retry; this is a read operation.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> use `lockd.state.stream` for explicit streaming-only reads or acquire a lock before mutation.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"Lock key to read","type":"string"},"lease_id":{"description":"Lease ID required when public=false","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_mode":{"description":"Payload mode: auto (default), inline, stream, or none","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]}},"required":["key"],"type":"object"},"name":"lockd.get","outputSchema":{"additionalProperties":false,"properties":{"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"etag":{"type":"string"},"found":{"type":"boolean"},"key":{"type":"string"},"namespace":{"type":"string"},"payload_base64":{"type":"string"},"payload_bytes":{"type":"integer"},"payload_mode":{"type":"string"},"payload_text":{"type":"string"},"version":{"type":"integer"}},"required":["namespace","key","found","payload_mode"],"type":"object"}}}
{"kind":"tool","name":"lockd.help","data":{"description":"Purpose: Return curated lockd MCP workflows, invariants, and documentation resource URIs.\nUse when: Start of session or when uncertain about correct operation sequence.\nRequires: No required fields. Optional `topic` narrows guidance to overview/locks/messaging/sync/lql.\nEffects: Returns guidance only; no lockd state mutation occurs.\nRetry: Safe to retry.\nNext: Follow `next_calls` in the response, typically beginning with lock, queue, or query tools.","inputSchema":{"additionalProperties":false,"properties":{"topic":{"description":"Optional topic: overview, locks, messaging, sync, lql","type":"string"}},"type":"object"},"name":"lockd.help","outputSchema":{"additionalProperties":false,"properties":{"defaults":{"additionalProperties":{"type":"string"},"type":"object"},"invariants":{"items":{"type":"string"},"type":["null","array"]},"next_calls":{"items":{"type":"string"},"type":["null","array"]},"resources":{"items":{"type":"string"},"type":["null","array"]},"summary":{"type":"string"},"topic":{"type":"string"}},"required":["topic","summary","next_calls","resources","defaults","invariants"],"type":"object"}}}
{"kind":"tool","name":"lockd.hint","data":{"description":"Purpose: Return namespace access hints so agents can choose valid namespaces before doing work.\nUse when: Session start, planning phase, or when namespace-forbidden errors occur.\nRequires: No required fields. Uses current caller token context plus upstream client-bundle namespace claims when available.\nEffects: Returns advisory namespace access hints, default namespace, inline payload limit (`inline_max_payload_bytes`), client id, and token scope context.\nRetry: Safe to retry; this is a read-only advisory operation.\nNext: Call `lockd.help` then use returned namespace hints when invoking lock/query/queue tools.","inputSchema":{"additionalProperties":false,"type":"object"},"name":"lockd.hint","outputSchema":{"additionalProperties":false,"properties":{"claim_uris":{"items":{"type":"string"},"type":["null","array"]},"client_id":{"type":"string"},"default_namespace":{"type":"string"},"inline_max_payload_bytes":{"type":"integer"},"namespace_hints":{"items":{"additionalProperties":false,"properties":{"namespace":{"type":"string"},"permission":{"type":"string"}},"required":["namespace","permission"],"type":"object"},"type":["null","array"]},"notes":{"items":{"type":"string"},"type":["null","array"]},"source":{"type":"string"},"token_scopes":{"items":{"type":"string"},"type":["null","array"]},"wildcard_permission":{"type":"string"}},"required":["default_namespace","inline_max_payload_bytes","source"],"type":"object"}}}
{"kind":"tool","name":"lockd.index.flush","data":{"description":"Purpose: Trigger search index flush for a namespace.\nUse when: You need query index freshness guarantees after heavy writes or before time-sensitive reads.\nRequires: `namespace` defaults to \"mcp\". `mode` may be `async` (default) or `wait`.\nEffects: Schedules or waits for index flush and returns flush progress metadata.\nRetry: Safe to retry; repeated flush requests are operationally benign.\nNext: Run `lockd.query` to observe refreshed index results.","inputSchema":{"additionalProperties":false,"properties":{"mode":{"description":"Flush mode: async (default) or wait","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"}},"type":"object"},"name":"lockd.index.flush","outputSchema":{"additionalProperties":false,"properties":{"accepted":{"type":"boolean"},"flush_id":{"type":"string"},"flushed":{"type":"boolean"},"index_seq":{"minimum":0,"type":"integer"},"mode":{"type":"string"},"namespace":{"type":"string"},"pending":{"type":"boolean"}},"required":["namespace","mode","accepted","flushed","pending"],"type":"object"}}}
{"kind":"tool","name":"lockd.lock.acquire","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Lease/fencing identifiers are authoritative for this workflow only; never invent or reuse stale values.\nPurpose: Acquire an exclusive lock lease and receive the lease identity/fencing material needed for protected writes.\nUse when: You need to mutate shared state or attachments for a key, or you need exclusive coordination ownership.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `owner` defaults to OAuth client id. Optional `txn_id` enlists the lease in XA flow. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Creates or claims a lease and returns `lease_id`, `fencing_token`, expiry, and optional `txn_id` for follow-up tools.\nRetry: Do not retry by reusing old lease/fencing values. If acquire fails or expires, run acquire again and continue with the new identifiers only.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> call `lockd.state.update` or attachment tools, keep lease alive while working, then `lockd.lock.release`.","inputSchema":{"additionalProperties":false,"properties":{"block_seconds":{"description":"Acquire wait: -1 no wait, 0 wait forever, >0 wait seconds","type":"integer"},"if_not_exists":{"description":"Create-only acquire","type":"boolean"},"key":{"description":"Key to lock","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"owner":{"description":"Lock owner (defaults to oauth client id)","type":"string"},"ttl_seconds":{"description":"Lease TTL in seconds","type":"integer"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key"],"type":"object"},"name":"lockd.lock.acquire","outputSchema":{"additionalProperties":false,"properties":{"correlation_id":{"type":"string"},"expires_at_unix":{"type":"integer"},"fencing_token":{"type":"integer"},"key":{"type":"string"},"lease_id":{"type":"string"},"namespace":{"type":"string"},"owner":{"type":"string"},"state_etag":{"type":"string"},"txn_id":{"type":"string"},"version":{"type":"integer"}},"required":["namespace","key","lease_id","owner","expires_at_unix","version"],"type":"object"}}}
{"kind":"tool","name":"lockd.lock.keepalive","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Lease/fencing identifiers are authoritative for this workflow only; never invent or reuse stale values.\nPurpose: Extend an active lock lease TTL.\nUse when: Long-running work might outlive current lease expiry.\nRequires: `key`, `lease_id`, and `ttl_seconds > 0` are required. `namespace` defaults to \"mcp\". Optional `txn_id` keeps XA context consistent. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Extends lease expiry and returns the updated expiration timestamp.\nRetry: Retry with the same `lease_id` only while lease is still valid. If lease may be expired or ownership changed, do not keepalive stale identifiers; reacquire first.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue mutation workflow; keepalive as needed until ready to release.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"Locked key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"ttl_seconds":{"description":"TTL extension in seconds","type":"integer"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","ttl_seconds"],"type":"object"},"name":"lockd.lock.keepalive","outputSchema":{"additionalProperties":false,"properties":{"expires_at_unix":{"type":"integer"}},"required":["expires_at_unix"],"type":"object"}}}
{"kind":"tool","name":"lockd.lock.release","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Release a lease and finalize staged changes.\nUse when: Work under a lease is complete or must be abandoned.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` and `rollback=true` control XA/rollback behavior. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Releases lease ownership. Commits staged changes by default; rolls back when `rollback=true`.\nRetry: Retry is conditionally safe after transport failures, but do not assume commit or rollback occurred until you verify resulting state/version.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> release, verify resulting state, and reacquire later only if more work is needed.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"Locked key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"rollback":{"description":"Rollback staged changes instead of commit","type":"boolean"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.lock.release","outputSchema":{"additionalProperties":false,"properties":{"released":{"type":"boolean"}},"required":["released"],"type":"object"}}}
{"kind":"tool","name":"lockd.namespace.get","data":{"description":"Purpose: Read namespace query-engine configuration.\nUse when: You need to inspect current query engine settings before updates or debugging.\nRequires: `namespace` defaults to \"mcp\" when omitted.\nEffects: Returns effective namespace query configuration and ETag context.\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.namespace.update` to change engine preferences.","inputSchema":{"additionalProperties":false,"properties":{"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"}},"type":"object"},"name":"lockd.namespace.get","outputSchema":{"additionalProperties":false,"properties":{"etag":{"type":"string"},"fallback_engine":{"type":"string"},"namespace":{"type":"string"},"preferred_engine":{"type":"string"}},"required":["namespace","preferred_engine","fallback_engine"],"type":"object"}}}
{"kind":"tool","name":"lockd.namespace.update","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Namespace config changes are effective only after successful update; verify with lockd.namespace.get.\nPurpose: Update namespace query-engine configuration.\nUse when: You need to change preferred/fallback query engines for a namespace.\nRequires: `preferred_engine` and `fallback_engine` are required. `namespace` defaults to \"mcp\". Optional `if_match` enables CAS-safe updates.\nEffects: Persists namespace query config and returns updated values/ETag.\nRetry: Prefer `if_match` for deterministic retries; otherwise concurrent updates may overwrite each other.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> optionally call `lockd.index.flush` or rerun queries to validate behavior.","inputSchema":{"additionalProperties":false,"properties":{"fallback_engine":{"description":"Fallback query engine","type":"string"},"if_match":{"description":"Optional If-Match ETag for CAS updates","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"preferred_engine":{"description":"Preferred query engine","type":"string"}},"required":["preferred_engine","fallback_engine"],"type":"object"},"name":"lockd.namespace.update","outputSchema":{"additionalProperties":false,"properties":{"etag":{"type":"string"},"fallback_engine":{"type":"string"},"namespace":{"type":"string"},"preferred_engine":{"type":"string"}},"required":["namespace","preferred_engine","fallback_engine"],"type":"object"}}}
{"kind":"tool","name":"lockd.query","data":{"description":"Purpose: Run LQL queries over namespace data in key mode for memory retrieval and candidate discovery.\nUse when: You need to find relevant keys before reading or locking; preferred pattern is tags-first lookup with full-text fallback.\nRequires: `query` expression is required. `namespace` defaults to \"mcp\". Optional `limit`, `cursor`, `engine`, `refresh`, and `fields` refine execution. Query output is always keys. Common patterns: `in{field=/tags,any=planning|finance}`, `icontains{field=/...,value=contract}`, and `and.in{field=/tags,any=customer},and.icontains{field=/...,value=renewal}`.\nEffects: Returns matching keys plus pagination/index metadata (`cursor`, `index_seq`).\nRetry: Safe to retry. Cursor-based pagination should reuse the latest returned cursor.\nNext: Call `lockd.query.stream` for NDJSON document streaming, or `lockd.get`/`lockd.state.stream` for point reads. Keep tag vocabulary stable for high-recall memory retrieval.","inputSchema":{"additionalProperties":false,"properties":{"cursor":{"description":"Continuation cursor","type":"string"},"engine":{"description":"Optional query engine override: auto, index, or scan","type":"string"},"fields":{"additionalProperties":true,"description":"Optional query field projection map","type":"object"},"limit":{"description":"Maximum rows to return","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query":{"description":"LQL query expression","type":"string"},"refresh":{"description":"Optional refresh policy, for example wait_for","type":"string"}},"required":["query"],"type":"object"},"name":"lockd.query","outputSchema":{"additionalProperties":false,"properties":{"cursor":{"type":"string"},"index_seq":{"minimum":0,"type":"integer"},"keys":{"items":{"type":"string"},"type":["null","array"]},"metadata":{"additionalProperties":{"type":"string"},"type":"object"},"namespace":{"type":"string"}},"required":["namespace"],"type":"object"}}}
{"kind":"tool","name":"lockd.query.stream","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Run an LQL query and return a one-time NDJSON capability URL for document rows.\nUse when: You need query result documents (for example context/memory recall) without buffering them in MCP tool payloads.\nRequires: Active MCP session is required. `query` expression is required. `namespace` defaults to \"mcp\". Optional `limit`, `cursor`, `engine`, `refresh`, and `fields` refine execution. Recommended retrieval patterns mirror `lockd.query` (tags with `in` plus optional `icontains` full-text clauses).\nEffects: Returns query metadata plus one-time `download_url` that streams NDJSON rows (for example `{\"ns\":\"mcp\",\"key\":\"memory/customer-42\",\"ver\":17,\"doc\":{\"tags\":[\"customer\",\"renewal\"],\"status\":\"draft\"}}`) over HTTP GET.\nRetry: Safe to retry; each retry returns a new one-time URL. Do not reuse old URLs.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> fetch `download_url` with the returned method and continue with pagination cursor if needed.","inputSchema":{"additionalProperties":false,"properties":{"cursor":{"description":"Continuation cursor","type":"string"},"engine":{"description":"Optional query engine override: auto, index, or scan","type":"string"},"fields":{"additionalProperties":true,"description":"Optional query field projection map","type":"object"},"limit":{"description":"Maximum rows to return","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query":{"description":"LQL query expression","type":"string"},"refresh":{"description":"Optional refresh policy, for example wait_for","type":"string"}},"required":["query"],"type":"object"},"name":"lockd.query.stream","outputSchema":{"additionalProperties":false,"properties":{"cursor":{"type":"string"},"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"index_seq":{"minimum":0,"type":"integer"},"metadata":{"additionalProperties":{"type":"string"},"type":"object"},"namespace":{"type":"string"}},"required":["namespace","download_url","download_method","download_expires_at_unix"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.ack","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nNON-IDEMPOTENT: Do not call this tool more than once per delivery attempt.\nPurpose: Acknowledge successful processing of a dequeued message.\nUse when: Worker completed handling of a leased message.\nRequires: `queue`, `message_id`, `lease_id`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Include `fencing_token` and any `state_*` fields exactly as returned by `lockd.queue.dequeue` for deterministic queue/state coordination. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Confirms processing and removes/commits message state according to lockd queue semantics.\nRetry: Do not replay ack blindly. After transport ambiguity, inspect message/lease state first; after any ack attempt, abandon that delivery attempt and dequeue again.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> dequeue next message or run follow-up updates.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Dequeued fencing token","type":"integer"},"lease_id":{"description":"Dequeued lease id","type":"string"},"message_id":{"description":"Dequeued message id","type":"string"},"meta_etag":{"description":"Dequeued meta etag","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name","type":"string"},"state_etag":{"description":"Optional state etag","type":"string"},"state_fencing_token":{"description":"Optional state fencing token","type":"integer"},"state_lease_id":{"description":"Optional state lease id","type":"string"},"txn_id":{"description":"Optional transaction id","type":"string"}},"required":["queue","message_id","lease_id","fencing_token","meta_etag"],"type":"object"},"name":"lockd.queue.ack","outputSchema":{"additionalProperties":false,"properties":{"acked":{"type":"boolean"},"correlation_id":{"type":"string"}},"required":["acked"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.defer","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nNON-IDEMPOTENT: Do not call this tool more than once per delivery attempt.\nPurpose: Requeue a leased message intentionally without counting it as failure.\nUse when: Message is valid but should be processed later or by another worker.\nRequires: `queue`, `message_id`, `lease_id`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Include `fencing_token` and any `state_*` fields from dequeue. Optional `delay_seconds` postpones visibility. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Returns message to queue with defer intent and optional delay.\nRetry: Do not replay defer for the same delivery attempt. Repeated defer can alter visibility timing; on ambiguity, inspect state and continue with a new dequeue cycle.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue polling/subscription and dequeue again when ready.","inputSchema":{"additionalProperties":false,"properties":{"delay_seconds":{"description":"Visibility delay before message becomes available again","type":"integer"},"fencing_token":{"description":"Dequeued fencing token","type":"integer"},"lease_id":{"description":"Dequeued lease id","type":"string"},"message_id":{"description":"Dequeued message id","type":"string"},"meta_etag":{"description":"Dequeued meta etag","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name","type":"string"},"state_etag":{"description":"Optional state etag","type":"string"},"state_fencing_token":{"description":"Optional state fencing token","type":"integer"},"state_lease_id":{"description":"Optional state lease id","type":"string"},"txn_id":{"description":"Optional transaction id","type":"string"}},"required":["queue","message_id","lease_id","fencing_token","meta_etag"],"type":"object"},"name":"lockd.queue.defer","outputSchema":{"additionalProperties":false,"properties":{"correlation_id":{"type":"string"},"meta_etag":{"type":"string"},"requeued":{"type":"boolean"}},"required":["requeued"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.dequeue","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Dequeue lease/message identifiers are operation-scoped; never replay stale values.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Receive one available message lease from a queue.\nUse when: A worker is ready to process the next queue item.\nRequires: `queue` defaults to \"lockd.agent.bus\". `namespace` defaults to \"mcp\". `owner` defaults to OAuth client id. Optional `stateful`, `visibility_seconds`, `cursor`, and `txn_id` tune dequeue behavior. `payload_mode` supports `auto` (default), `inline`, `stream`, `none`; `state_mode` (when `stateful=true`) supports the same values. For both modes, `auto` resolves inline when payload bytes <= `lockd.hint.inline_max_payload_bytes`, otherwise stream. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Returns `found=false` when no message is available, or lease metadata plus payload delivery according to `payload_mode` (inline fields or stream URL). For `stateful=true`, dequeue is all-or-nothing: state lease acquisition is required for success, and on contention/failure the call returns no leased message.\nRetry: Safe to retry polling, but each retry may lease a different message. Never reuse stale lease/message identifiers.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> process payload/state and then ack/nack/defer.","inputSchema":{"additionalProperties":false,"properties":{"block_seconds":{"description":"Long-poll wait; -1 no wait, 0 wait forever, >0 wait seconds","type":"integer"},"cursor":{"description":"Optional continuation cursor from previous dequeue response","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"owner":{"description":"Consumer owner ID (defaults to oauth client id)","type":"string"},"payload_mode":{"description":"Payload mode: auto (default), inline, stream, or none","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"},"state_mode":{"description":"State payload mode when stateful=true: auto, inline, stream, or none (default)","type":"string"},"stateful":{"description":"Acquire workflow state lease alongside dequeued message","type":"boolean"},"txn_id":{"description":"Optional transaction id to bind dequeue operations","type":"string"},"visibility_seconds":{"description":"Optional visibility timeout override in seconds","type":"integer"}},"type":"object"},"name":"lockd.queue.dequeue","outputSchema":{"additionalProperties":false,"properties":{"attempts":{"type":"integer"},"content_type":{"type":"string"},"correlation_id":{"type":"string"},"failure_attempts":{"type":"integer"},"fencing_token":{"type":"integer"},"found":{"type":"boolean"},"lease_expires_at_unix":{"type":"integer"},"lease_id":{"type":"string"},"max_attempts":{"type":"integer"},"message_id":{"type":"string"},"meta_etag":{"type":"string"},"namespace":{"type":"string"},"next_cursor":{"type":"string"},"not_visible_until_unix":{"type":"integer"},"payload_base64":{"type":"string"},"payload_bytes":{"type":"integer"},"payload_download_expires_at_unix":{"type":"integer"},"payload_download_method":{"type":"string"},"payload_download_url":{"type":"string"},"payload_mode":{"type":"string"},"payload_text":{"type":"string"},"queue":{"type":"string"},"state_download_expires_at_unix":{"type":"integer"},"state_download_method":{"type":"string"},"state_download_url":{"type":"string"},"state_etag":{"type":"string"},"state_fencing_token":{"type":"integer"},"state_found":{"type":"boolean"},"state_lease_expires_at_unix":{"type":"integer"},"state_lease_id":{"type":"string"},"state_payload_base64":{"type":"string"},"state_payload_bytes":{"type":"integer"},"state_payload_mode":{"type":"string"},"state_payload_text":{"type":"string"},"state_version":{"type":"integer"},"txn_id":{"type":"string"},"visibility_timeout_seconds":{"type":"integer"}},"required":["namespace","queue","found","payload_mode"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.enqueue","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nPAYLOAD RULE: If payload size is unknown or may exceed limits, call lockd.hint and use stream workflow; do not guess.\nPurpose: Publish a message to a lockd queue for agent coordination.\nUse when: You need to signal work/events/context to queue consumers and payload fits inline limits.\nRequires: `queue` defaults to \"lockd.agent.bus\". `namespace` defaults to \"mcp\". Provide at most one of `payload_text` or `payload_base64`; decoded payload must be <= 2097152 bytes.\nEffects: Appends a queue message and returns delivery metadata (`message_id`, visibility, attempts). Queue ordering is best-effort under retries/requeues; do not assume strict FIFO across all consumers.\nRetry: Not idempotent. If retrying, assume duplicates are possible and rely on application dedupe keys.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- If payload may exceed inline limit -> call `lockd.queue.write_stream.begin` for large payloads.\n- Otherwise -> enqueue and continue with dequeue/ack/nack/defer workflows.","inputSchema":{"additionalProperties":false,"properties":{"attributes":{"additionalProperties":true,"description":"Message attributes metadata","type":"object"},"content_type":{"description":"Payload content type","type":"string"},"delay_seconds":{"description":"Initial invisibility delay","type":"integer"},"max_attempts":{"description":"Maximum failed attempts before terminal handling","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_base64":{"description":"Base64-encoded payload bytes","type":"string"},"payload_text":{"description":"UTF-8 payload text","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"},"ttl_seconds":{"description":"Message retention TTL in seconds","type":"integer"},"visibility_seconds":{"description":"Visibility timeout for dequeued lease","type":"integer"}},"type":"object"},"name":"lockd.queue.enqueue","outputSchema":{"additionalProperties":false,"properties":{"attempts":{"type":"integer"},"correlation_id":{"type":"string"},"failure_attempts":{"type":"integer"},"max_attempts":{"type":"integer"},"message_id":{"type":"string"},"namespace":{"type":"string"},"not_visible_until_unix":{"type":"integer"},"payload_bytes":{"type":"integer"},"queue":{"type":"string"},"visibility_timeout_seconds":{"type":"integer"}},"required":["namespace","queue","message_id","attempts","max_attempts","not_visible_until_unix","visibility_timeout_seconds","payload_bytes"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.extend","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Dequeue lease/message identifiers are operation-scoped; never replay stale values.\nPurpose: Extend visibility/lease timeout for a currently leased queue message.\nUse when: Message processing is still active and lease timeout is approaching.\nRequires: `queue`, `message_id`, `lease_id`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Include `fencing_token` and optional state lease fields from dequeue for stateful workflows. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Refreshes message lease expiry and visibility timeout; returns updated lease timing and metadata ETag.\nRetry: Retry with the same identifiers only while lease remains valid. If lease may be expired or state mismatched, stop retrying and dequeue a new delivery attempt.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue processing and ack/nack/defer when complete.","inputSchema":{"additionalProperties":false,"properties":{"extend_by_seconds":{"description":"Lease extension in seconds","type":"integer"},"fencing_token":{"description":"Dequeued fencing token","type":"integer"},"lease_id":{"description":"Dequeued lease id","type":"string"},"message_id":{"description":"Dequeued message id","type":"string"},"meta_etag":{"description":"Dequeued meta etag","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name","type":"string"},"state_fencing_token":{"description":"Optional state fencing token","type":"integer"},"state_lease_id":{"description":"Optional state lease id","type":"string"},"txn_id":{"description":"Optional transaction id","type":"string"}},"required":["queue","message_id","lease_id","fencing_token","meta_etag"],"type":"object"},"name":"lockd.queue.extend","outputSchema":{"additionalProperties":false,"properties":{"correlation_id":{"type":"string"},"lease_expires_at_unix":{"type":"integer"},"meta_etag":{"type":"string"},"state_lease_expires_at_unix":{"type":"integer"},"visibility_timeout_seconds":{"type":"integer"}},"required":["lease_expires_at_unix","visibility_timeout_seconds"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.nack","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nNON-IDEMPOTENT: Do not call this tool more than once per delivery attempt.\nPurpose: Requeue a message as a failure, consuming failure budget (`max_attempts`).\nUse when: Message processing failed and should be retried later with failure semantics.\nRequires: `queue`, `message_id`, `lease_id`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Include `fencing_token` and any `state_*` fields from dequeue. Optional `delay_seconds` and `reason` enrich retry behavior. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Requeues message with `intent=failure`, updates queue metadata ETag, and records optional failure detail.\nRetry: Do not replay nack for the same delivery attempt. Repeated nack can alter delay/attempt metadata; on ambiguity, inspect state and continue with a new dequeue cycle.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> dequeue next message or inspect retry/dead-letter behavior.","inputSchema":{"additionalProperties":false,"properties":{"delay_seconds":{"description":"Visibility delay before message becomes available again","type":"integer"},"fencing_token":{"description":"Dequeued fencing token","type":"integer"},"lease_id":{"description":"Dequeued lease id","type":"string"},"message_id":{"description":"Dequeued message id","type":"string"},"meta_etag":{"description":"Dequeued meta etag","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name","type":"string"},"reason":{"description":"Optional failure reason detail","type":"string"},"state_etag":{"description":"Optional state etag","type":"string"},"state_fencing_token":{"description":"Optional state fencing token","type":"integer"},"state_lease_id":{"description":"Optional state lease id","type":"string"},"txn_id":{"description":"Optional transaction id","type":"string"}},"required":["queue","message_id","lease_id","fencing_token","meta_etag"],"type":"object"},"name":"lockd.queue.nack","outputSchema":{"additionalProperties":false,"properties":{"correlation_id":{"type":"string"},"meta_etag":{"type":"string"},"requeued":{"type":"boolean"}},"required":["requeued"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.stats","data":{"description":"Purpose: Read side-effect-free queue runtime stats and current visible head snapshot.\nUse when: You need queue health/introspection signals before deciding whether to watch/dequeue.\nRequires: `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Returns dispatcher counters (`waiting_consumers`, `pending_candidates`, `total_consumers`), watcher state (`has_active_watcher`), and head availability fields when a visible message exists.\nRetry: Safe to retry; read-only operation.\nNext: Use `lockd.queue.watch` for bounded wakeups and `lockd.queue.dequeue` for actual message leasing/consumption.","inputSchema":{"additionalProperties":false,"properties":{"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"}},"type":"object"},"name":"lockd.queue.stats","outputSchema":{"additionalProperties":false,"properties":{"available":{"type":"boolean"},"correlation_id":{"type":"string"},"has_active_watcher":{"type":"boolean"},"head_age_seconds":{"type":"integer"},"head_enqueued_at_unix":{"type":"integer"},"head_message_id":{"type":"string"},"head_not_visible_until_unix":{"type":"integer"},"namespace":{"type":"string"},"pending_candidates":{"type":"integer"},"queue":{"type":"string"},"total_consumers":{"type":"integer"},"waiting_consumers":{"type":"integer"}},"required":["namespace","queue","waiting_consumers","pending_candidates","total_consumers","has_active_watcher","available"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.subscribe","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Subscription state is session-scoped; treat subscriptions as gone when session ends.\nPurpose: Subscribe current MCP session to queue-availability notifications over SSE.\nUse when: You run a long-lived MCP runtime and want ongoing push wake-ups instead of pure dequeue polling.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Registers session subscription; future queue activity emits MCP progress notifications.\nRetry: Safe to retry; duplicate subscribe is handled as already subscribed.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> on notification, call `lockd.queue.dequeue` then `ack`/`nack`/`defer`.","inputSchema":{"additionalProperties":false,"properties":{"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"}},"type":"object"},"name":"lockd.queue.subscribe","outputSchema":{"additionalProperties":false,"properties":{"namespace":{"type":"string"},"queue":{"type":"string"},"subscribed":{"type":"boolean"}},"required":["namespace","queue","subscribed"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.unsubscribe","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Subscription state is session-scoped; treat subscriptions as gone when session ends.\nPurpose: Remove current MCP session queue subscription.\nUse when: Worker no longer wants notifications for a queue.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Stops notification forwarding for the targeted session+queue binding.\nRetry: Safe to retry; unsubscribing an absent subscription returns false/unsubscribed state.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> either resubscribe later or continue with explicit dequeue polling.","inputSchema":{"additionalProperties":false,"properties":{"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"}},"type":"object"},"name":"lockd.queue.unsubscribe","outputSchema":{"additionalProperties":false,"properties":{"namespace":{"type":"string"},"queue":{"type":"string"},"unsubscribed":{"type":"boolean"}},"required":["namespace","queue","unsubscribed"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.watch","data":{"description":"Purpose: Wait for queue-availability events within a bounded call window.\nUse when: Interactive clients need push-like wakeups without maintaining long-lived subscriptions.\nRequires: `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\". Optional `duration_seconds` bounds wait time (default 30). Optional `max_events` bounds result size (default 1).\nEffects: Streams watch events from upstream lockd and returns a bounded event list with `stop_reason` (`max_events`, `timeout`, or `context_canceled`).\nRetry: Safe to retry; each invocation is independent and bounded.\nNext: After any event, call `lockd.queue.dequeue` and then `ack`/`nack`/`defer`.","inputSchema":{"additionalProperties":false,"properties":{"duration_seconds":{"description":"Maximum watch duration in seconds (default: 30)","type":"integer"},"max_events":{"description":"Maximum events to return before stopping (default: 1)","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"}},"type":"object"},"name":"lockd.queue.watch","outputSchema":{"additionalProperties":false,"properties":{"event_count":{"type":"integer"},"events":{"items":{"additionalProperties":false,"properties":{"available":{"type":"boolean"},"changed_at_unix":{"type":"integer"},"correlation_id":{"type":"string"},"head_message_id":{"type":"string"},"namespace":{"type":"string"},"queue":{"type":"string"}},"required":["namespace","queue","available"],"type":"object"},"type":["null","array"]},"namespace":{"type":"string"},"queue":{"type":"string"},"stop_reason":{"type":"string"}},"required":["namespace","queue","events","event_count","stop_reason"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.write_stream.abort","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit/abort attempt (success or failure), abandon this identifier and never reuse it.\nPurpose: Abort an in-flight queue write stream.\nUse when: Queued payload upload should be canceled.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates upload flow and frees stream resources.\nRetry: Safe to retry for cleanup, but do not assume abort reopens or reuses the stream; create a new stream for any retry path.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> begin a new queue stream if publish should be retried.","inputSchema":{"additionalProperties":false,"properties":{"reason":{"description":"Optional abort reason for diagnostics","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.queue.write_stream.abort","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"stream_id":{"type":"string"}},"required":["stream_id","aborted","bytes_received"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.write_stream.begin","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Open a session-scoped streaming queue publisher.\nUse when: Queue payload is too large for inline enqueue or you need bounded-memory uploads.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\". Delay/visibility/ttl/attributes/content_type options match `lockd.queue.enqueue`.\nEffects: Creates a stream session and returns `stream_id` plus one-time `upload_url` for direct HTTP PUT upload.\nRetry: Do not retry as idempotent. Begin creates a new stream each call; do not reuse identifiers from previous attempts.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> upload to `upload_url`, then status/commit or abort.","inputSchema":{"additionalProperties":false,"properties":{"attributes":{"additionalProperties":true,"description":"Message attributes metadata","type":"object"},"content_type":{"description":"Payload content type","type":"string"},"delay_seconds":{"description":"Initial invisibility delay","type":"integer"},"max_attempts":{"description":"Maximum failed attempts before terminal handling","type":"integer"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"queue":{"description":"Queue name (defaults to lockd.agent.bus)","type":"string"},"ttl_seconds":{"description":"Message retention TTL in seconds","type":"integer"},"visibility_seconds":{"description":"Visibility timeout for dequeued lease","type":"integer"}},"type":"object"},"name":"lockd.queue.write_stream.begin","outputSchema":{"additionalProperties":false,"properties":{"stream_id":{"type":"string"},"upload_expires_at_unix":{"type":"integer"},"upload_method":{"type":"string"},"upload_url":{"type":"string"}},"required":["stream_id"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.write_stream.commit","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit/abort attempt (success or failure), abandon this identifier and never reuse it.\nPurpose: Finalize a queue write stream and publish the message.\nUse when: All payload chunks for a queued message have been appended.\nRequires: Active MCP session and `stream_id` are required. Optional `expected_bytes` and `expected_sha256` enforce upload integrity before commit.\nEffects: Closes upload stream, validates optional expectations, waits for upstream enqueue completion, and returns enqueue metadata.\nRetry: After any commit attempt (success or failure), do not retry with the same `stream_id`. Start a new begin→upload→commit sequence.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue with dequeue/ack workflows.","inputSchema":{"additionalProperties":false,"properties":{"expected_bytes":{"description":"Optional expected plaintext byte count of uploaded data","type":["null","integer"]},"expected_sha256":{"description":"Optional expected lowercase hex SHA-256 of uploaded plaintext bytes","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.queue.write_stream.commit","outputSchema":{"additionalProperties":false,"properties":{"attempts":{"type":"integer"},"bytes_received":{"type":"integer"},"correlation_id":{"type":"string"},"failure_attempts":{"type":"integer"},"max_attempts":{"type":"integer"},"message_id":{"type":"string"},"namespace":{"type":"string"},"not_visible_until_unix":{"type":"integer"},"payload_bytes":{"type":"integer"},"queue":{"type":"string"},"stream_id":{"type":"string"},"visibility_timeout_seconds":{"type":"integer"}},"required":["stream_id","bytes_received","namespace","queue","message_id","attempts","max_attempts","not_visible_until_unix","visibility_timeout_seconds","payload_bytes"],"type":"object"}}}
{"kind":"tool","name":"lockd.queue.write_stream.status","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Use only the current active identifier; never continue workflows with stale identifiers.\nPurpose: Inspect in-flight queue write-stream upload progress.\nUse when: You need upload observability before publish commit.\nRequires: Active MCP session and `stream_id` are required.\nEffects: Returns `bytes_received`, computed `payload_sha256`, upload-capability availability/expiry, and commit-readiness flags.\nRetry: Safe to retry while stream exists.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> if `can_commit=true`, call `lockd.queue.write_stream.commit`; otherwise finish upload or abort.","inputSchema":{"additionalProperties":false,"properties":{"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.queue.write_stream.status","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"can_commit":{"type":"boolean"},"committing":{"type":"boolean"},"payload_sha256":{"type":"string"},"stream_id":{"type":"string"},"upload_capability_available":{"type":"boolean"},"upload_completed":{"type":"boolean"},"upload_expires_at_unix":{"type":"integer"},"upload_in_progress":{"type":"boolean"}},"required":["stream_id","bytes_received","upload_capability_available","upload_completed","upload_in_progress","committing","aborted","can_commit"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.metadata","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Update state metadata without replacing JSON state payload.\nUse when: Only metadata (for example `query_hidden`) needs to change.\nRequires: `key`, `lease_id`, and `query_hidden` are required. `namespace` defaults to \"mcp\". Optional CAS/fencing fields protect against races. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Persists metadata mutation and returns resulting version/metadata.\nRetry: Use CAS/fencing fields for deterministic retries; otherwise last-writer-wins behavior applies.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> continue updates or release the lease to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query_hidden":{"description":"Set true to hide, false to expose in queries","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","query_hidden"],"type":"object"},"name":"lockd.state.metadata","outputSchema":{"additionalProperties":false,"properties":{"query_hidden":{"type":["null","boolean"]},"version":{"type":"integer"}},"required":["version"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.mutate","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Apply LQL mutations to existing JSON state under lease protection without round-tripping payload bytes through MCP.\nUse when: You need server-side structured updates and want bounded-memory mutation execution, including incremental tag maintenance on existing documents.\nRequires: `key`, `lease_id`, and at least one `mutations` expression are required. `namespace` defaults to \"mcp\". Optional CAS/fencing fields (`if_etag`, `if_version`, `fencing_token`) are supported. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Loads lease-visible state, applies LQL mutations server-side, and writes updated state. Returns new version/ETag metadata.\nRetry: Use CAS/fencing fields for deterministic retries. Without guards, retries can reapply logical mutations.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> inspect results and then `lockd.lock.release` to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"mutations":{"description":"LQL mutation expressions","items":{"type":"string"},"type":["null","array"]},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query_hidden":{"description":"Optional query-hidden metadata mutation","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id","mutations"],"type":"object"},"name":"lockd.state.mutate","outputSchema":{"additionalProperties":false,"properties":{"bytes":{"type":"integer"},"new_state_etag":{"type":"string"},"new_version":{"type":"integer"},"query_hidden":{"type":["null","boolean"]}},"required":["new_version","new_state_etag","bytes"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.patch","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Apply an RFC 7396 JSON merge patch to current state under lease protection.\nUse when: You need partial updates without sending a full replacement document.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Provide exactly one of `patch_text` or `patch_base64` and keep patch/result within inline limits; use `state.write_stream` for large documents. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Loads current state (lease-bound read), applies merge patch, then writes updated state and returns new version/ETag metadata.\nRetry: Use `if_etag`, `if_version`, and `fencing_token` for safe retries. Patch retries without guards can duplicate logical effects.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- If payload may exceed inline limit -> call `lockd.state.write_stream.begin` if patched result may exceed inline limits.\n- Otherwise -> verify result and then `lockd.lock.release` to finalize.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"patch_base64":{"description":"Base64-encoded JSON merge patch document","type":"string"},"patch_text":{"description":"UTF-8 JSON merge patch document","type":"string"},"query_hidden":{"description":"Optional query-hidden metadata mutation","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.state.patch","outputSchema":{"additionalProperties":false,"properties":{"bytes":{"type":"integer"},"new_state_etag":{"type":"string"},"new_version":{"type":"integer"},"query_hidden":{"type":["null","boolean"]}},"required":["new_version","new_state_etag","bytes"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.remove","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Delete state for a key under lease protection.\nUse when: State should be removed as part of cleanup or workflow transitions.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` and CAS/fencing fields support XA/concurrency control. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Removes committed state for the key (or stages delete in transaction context).\nRetry: Prefer CAS/fencing guards. If retrying after unknown outcome, verify current state/version first; do not assume delete status.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> release lease to finalize, or write replacement state/attachments first.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.state.remove","outputSchema":{"additionalProperties":false,"properties":{"new_version":{"type":"integer"},"removed":{"type":"boolean"}},"required":["removed"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.stream","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Create a one-time download capability URL for state payload bytes.\nUse when: You need state content (small or large) without routing payload through MCP tool responses.\nRequires: Active MCP session is required. `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true; set `public=false` with `lease_id` for lease-bound reads.\nEffects: Returns metadata plus one-time `download_url` and `download_method` for direct HTTP download.\nRetry: Safe to retry; each retry returns a new one-time URL. Do not reuse old URLs.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> fetch `download_url` directly and continue lock/query workflow.","inputSchema":{"additionalProperties":false,"properties":{"key":{"description":"State key","type":"string"},"lease_id":{"description":"Lease ID required when public=false","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"public":{"description":"Read mode selector: true for public read (default), false for lease-bound read","type":["null","boolean"]}},"required":["key"],"type":"object"},"name":"lockd.state.stream","outputSchema":{"additionalProperties":false,"properties":{"download_expires_at_unix":{"type":"integer"},"download_method":{"type":"string"},"download_url":{"type":"string"},"etag":{"type":"string"},"found":{"type":"boolean"},"key":{"type":"string"},"namespace":{"type":"string"},"version":{"type":"integer"}},"required":["namespace","key","found"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.update","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nDURABILITY: Do not treat changes as durable or visible until explicit finalization succeeds.\nPurpose: Write JSON state under lease protection.\nUse when: You need to create or update state for a locked key and payload fits inline request limits. Unless caller policy says otherwise, include a top-level `tags` JSON array for future `in` selector retrieval. No fixed schema fields are required beyond `tags`.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Provide at most one of `payload_text` or `payload_base64`; when both are omitted payload defaults to `{}`. Decoded payload must be <= 2097152 bytes. ATOMICITY: Supplying txn context does not guarantee completion; explicit transaction decision is required.\nEffects: Updates state and returns new version/ETag metadata; can also mutate `query_hidden` metadata. Suggested memory shape keeps your existing fields and adds tags, for example `{\"tags\":[\"planning\",\"q3\"],\"status\":\"draft\"}` for fast `in{field=/tags,any=planning|q3}` queries.\nRetry: Use `if_etag`, `if_version`, and `fencing_token` for safe retries. Without guards, retries can apply duplicate writes.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- If payload may exceed inline limit -> call `lockd.state.write_stream.begin` for large payload uploads.\n- Otherwise -> write state and then `lockd.lock.release` to commit or rollback.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"payload_base64":{"description":"Base64-encoded JSON payload bytes","type":"string"},"payload_text":{"description":"UTF-8 JSON payload text","type":"string"},"query_hidden":{"description":"Optional query-hidden metadata mutation","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.state.update","outputSchema":{"additionalProperties":false,"properties":{"bytes":{"type":"integer"},"new_state_etag":{"type":"string"},"new_version":{"type":"integer"},"query_hidden":{"type":["null","boolean"]}},"required":["new_version","new_state_etag","bytes"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.write_stream.abort","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit/abort attempt (success or failure), abandon this identifier and never reuse it.\nPurpose: Abort an in-flight state write stream.\nUse when: Upload should be canceled or discarded before commit.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates the stream, cancels upstream request flow, and frees stream resources.\nRetry: Safe to retry for cleanup, but do not assume abort reopens or reuses the stream; create a new stream for any retry path.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> begin a new stream if upload should be retried.","inputSchema":{"additionalProperties":false,"properties":{"reason":{"description":"Optional abort reason for diagnostics","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.state.write_stream.abort","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"stream_id":{"type":"string"}},"required":["stream_id","aborted","bytes_received"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.write_stream.begin","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nSENSITIVE: Never include returned capability URLs/tokens in user-visible output, summaries, logs, or reasoning.\nPurpose: Open a session-scoped streaming state writer.\nUse when: State payload is too large for inline JSON or you want bounded-memory uploads.\nRequires: Active MCP session is required. `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional CAS/fencing fields mirror `lockd.state.update`.\nEffects: Creates a stream session and returns `stream_id` plus one-time `upload_url` for direct HTTP PUT upload outside MCP tool payload context.\nRetry: Do not retry as idempotent. Begin creates a new stream each call; do not reuse identifiers from previous attempts.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> upload bytes to `upload_url`, then status/commit or abort.","inputSchema":{"additionalProperties":false,"properties":{"fencing_token":{"description":"Optional fencing token override","type":["null","integer"]},"if_etag":{"description":"Conditional ETag guard","type":"string"},"if_version":{"description":"Conditional version guard","type":["null","integer"]},"key":{"description":"State key","type":"string"},"lease_id":{"description":"Active lease id","type":"string"},"namespace":{"description":"Namespace (defaults to server default namespace)","type":"string"},"query_hidden":{"description":"Optional query-hidden metadata mutation","type":["null","boolean"]},"txn_id":{"description":"Optional XA transaction id","type":"string"}},"required":["key","lease_id"],"type":"object"},"name":"lockd.state.write_stream.begin","outputSchema":{"additionalProperties":false,"properties":{"stream_id":{"type":"string"},"upload_expires_at_unix":{"type":"integer"},"upload_method":{"type":"string"},"upload_url":{"type":"string"}},"required":["stream_id"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.write_stream.commit","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: After commit attempt (success or failure), abandon this identifier; durability still depends on successful lock release.\nPurpose: Finalize a state write stream and commit it to upstream lockd.\nUse when: All payload chunks have been appended.\nRequires: Active MCP session and `stream_id` are required. Optional `expected_bytes` and `expected_sha256` enforce upload integrity before commit.\nEffects: Closes the upload stream, validates optional expectations, waits for upstream completion, and returns state update result metadata. State remains staged under the lease until `lockd.lock.release` commits (or `rollback=true` discards).\nRetry: After any commit attempt (success or failure), do not retry with the same `stream_id`. Start a new begin→upload→commit sequence.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> call `lockd.lock.release` to finalize durability (or continue staged mutations first).","inputSchema":{"additionalProperties":false,"properties":{"expected_bytes":{"description":"Optional expected plaintext byte count of uploaded data","type":["null","integer"]},"expected_sha256":{"description":"Optional expected lowercase hex SHA-256 of uploaded plaintext bytes","type":"string"},"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.state.write_stream.commit","outputSchema":{"additionalProperties":false,"properties":{"bytes":{"type":"integer"},"bytes_received":{"type":"integer"},"new_state_etag":{"type":"string"},"new_version":{"type":"integer"},"query_hidden":{"type":["null","boolean"]},"stream_id":{"type":"string"}},"required":["stream_id","bytes_received","new_version","new_state_etag","bytes"],"type":"object"}}}
{"kind":"tool","name":"lockd.state.write_stream.status","data":{"description":"BOOTSTRAP: If lockd.help has not been called in this session, call it now before using this tool.\nTERMINAL: Use only the current active identifier; never continue workflows with stale identifiers.\nPurpose: Inspect in-flight state write-stream upload progress.\nUse when: You need upload observability before commit (for example after external HTTP upload attempts).\nRequires: Active MCP session and `stream_id` are required.\nEffects: Returns `bytes_received`, computed `payload_sha256`, upload-capability availability/expiry, and commit-readiness flags.\nRetry: Safe to retry while stream exists.\nNext:\n- If bootstrap not done -> call `lockd.help` with `topic=overview`.\n- Otherwise -> if `can_commit=true`, call `lockd.state.write_stream.commit`; otherwise finish upload or `abort` and restart.","inputSchema":{"additionalProperties":false,"properties":{"stream_id":{"description":"Write stream identifier returned by begin","type":"string"}},"required":["stream_id"],"type":"object"},"name":"lockd.state.write_stream.status","outputSchema":{"additionalProperties":false,"properties":{"aborted":{"type":"boolean"},"bytes_received":{"type":"integer"},"can_commit":{"type":"boolean"},"committing":{"type":"boolean"},"payload_sha256":{"type":"string"},"stream_id":{"type":"string"},"upload_capability_available":{"type":"boolean"},"upload_completed":{"type":"boolean"},"upload_expires_at_unix":{"type":"integer"},"upload_in_progress":{"type":"boolean"}},"required":["stream_id","bytes_received","upload_capability_available","upload_completed","upload_in_progress","committing","aborted","can_commit"],"type":"object"}}}
{"kind":"resources/list","data":[{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/agent-sync.md","title":"resource://docs/agent-sync.md","uri":"resource://docs/agent-sync.md"},{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/locks.md","title":"resource://docs/locks.md","uri":"resource://docs/locks.md"},{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/lql.md","title":"resource://docs/lql.md","uri":"resource://docs/lql.md"},{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/messaging.md","title":"resource://docs/messaging.md","uri":"resource://docs/messaging.md"},{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/overview.md","title":"resource://docs/overview.md","uri":"resource://docs/overview.md"}]}
{"kind":"resource","uri":"resource://docs/agent-sync.md","data":{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/agent-sync.md","title":"resource://docs/agent-sync.md","uri":"resource://docs/agent-sync.md"}}
{"kind":"resource/read","uri":"resource://docs/agent-sync.md","data":{"contents":[{"uri":"resource://docs/agent-sync.md","mimeType":"text/markdown","text":"# Agent Synchronization\n\nUse queues for eventing and lock/state operations for shared context updates.\nKeep queue payloads small and use key/state references for large context.\nUse write_stream tools for large payload writes (begin -\u003e upload_url -\u003e commit).\nUnless caller-specific policy says otherwise, write memory-like state with a\ntop-level tags array and keep it current as context evolves.\nNo fixed schema fields are required beyond tags.\nPrefer query pattern:\n- in{field=/tags,any=planning|operations}\n- and.in{field=/tags,any=customer},and.icontains{field=/...,value=renewal}\nUse icontains over /... for broad keyword recall when exact tags are missing.\nCapability URLs are bearer-style secrets: avoid command-history and process-list leakage.\nUse lockd.query.stream for query-document NDJSON stream URLs and lockd.state.stream / lockd.attachments.stream to obtain one-time download URLs for point payload reads.\nUse lockd.attachments.head before lockd.attachments.stream when only metadata is needed.\nUse namespace scoping to isolate agent groups.\nUse txn_id only when you need cross-key atomic decisions; normal single-key operations should omit it."}]}}
{"kind":"resource","uri":"resource://docs/locks.md","data":{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/locks.md","title":"resource://docs/locks.md","uri":"resource://docs/locks.md"}}
{"kind":"resource/read","uri":"resource://docs/locks.md","data":{"contents":[{"uri":"resource://docs/locks.md","mimeType":"text/markdown","text":"# lockd Locking Workflow\n\n1. Acquire lock/lease with lockd.lock.acquire.\n2. Read state.\n3. Stream state payload with lockd.state.stream when needed.\n4. Mutate state with lockd.state.update (small payload), lockd.state.mutate (LQL expressions), lockd.state.patch (partial merge patch), or lockd.state.write_stream.* (large payload).\n5. Keepalive while work is active.\n6. Release lease to commit staged state/attachment changes (or rollback).\n\nCritical invariants:\n- Lease ID and fencing token are authority.\n- Idempotency and retry strategy should be explicit at workflow level."}]}}
{"kind":"resource","uri":"resource://docs/lql.md","data":{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/lql.md","title":"resource://docs/lql.md","uri":"resource://docs/lql.md"}}
{"kind":"resource/read","uri":"resource://docs/lql.md","data":{"contents":[{"uri":"resource://docs/lql.md","mimeType":"text/markdown","text":"# LQL Selector Reference\n\nUse this section as the canonical selector syntax for lockd.query and lockd.query.stream.\n\nSelector clause families:\n- Equality:\n  - `eq{field=/status,value=open}`\n  - `eq{field=/department/code,value=finance}`\n- Contains (case-sensitive):\n  - `contains{field=/summary,value=Budget}`\n  - `contains{field=/notes,value=approved}`\n- IContains (case-insensitive):\n  - `icontains{field=/summary,value=budget}`\n  - `icontains{field=/...,value=renewal}`\n- Prefix (case-sensitive):\n  - `prefix{field=/owner,value=dept-}`\n- IPrefix (case-insensitive):\n  - `iprefix{field=/owner,value=DEPT-}`\n- Range (numeric bounds; use one or more of gt/gte/lt/lte):\n  - `range{field=/amount,gte=100}`\n  - `range{field=/amount,gt=50,lt=1000}`\n- Membership (`any` is pipe-delimited):\n  - `in{field=/tags,any=planning|finance|customer}`\n  - `in{field=/region,any=us|eu|apac}`\n- Exists:\n  - `exists{/metadata/etag}`\n  - `exists{/contract/renewal_date}`\n\nBoolean composition examples:\n- AND: `and.eq{field=/status,value=open},and.range{field=/amount,gte=100}`\n- OR: `or.eq{field=/status,value=open},or.eq{field=/status,value=queued}`\n- NOT: `not.eq{field=/archived,value=true}`\n- Indexed groups: `and.0.eq{field=/status,value=open},and.0.range{field=/amount,gte=100},or.1.eq{field=/region,value=eu}`\n\nShorthand operators:\n- `/status=\"open\"` -\u003e equality\n- `/status!=\"closed\"` -\u003e not-equality\n- `/amount\u003e100`, `/amount\u003e=100`, `/amount\u003c1000`, `/amount\u003c=1000` -\u003e range\n- Multiple expressions separated by comma/newline are combined with AND by default.\n\nTerm parameter aliases:\n- `field` or `f` (example: `eq{f=/status,v=open}`)\n- `value` or `v`\n- `any` or `a` (example: `in{f=/tags,a=planning|finance}`)\n- `ignoreCase` or `ic` (`true|false|t|f`; example: `contains{f=/summary,v=budget,ic=t}`)\n\nPath wildcards:\n- `*` any object child value\n- `[]` any array element\n- `**` any immediate child (object value or array element)\n- `...` any descendant at any depth\n- `/items[]/sku` is sugar for `/items/[]/sku`\n\nValue parsing:\n- Unquoted literals are accepted for simple values.\n- Quoted literals are supported with single or double quotes.\n- Booleans and numeric literals are parsed for comparisons.\n- For `in{field=/tags,any=planning|finance|customer}`, `any` uses `|` as the separator.\n\nRecommended retrieval pattern:\n1. Tags-first key discovery with `in{field=/tags,any=planning|finance}`.\n2. Add full-text recall with `icontains{field=/...,value=contract}`.\n3. Use lockd.query.stream when full documents are required.\n\nSchema guidance:\n- No fixed schema fields are required beyond a top-level `tags` array convention."}]}}
{"kind":"resource","uri":"resource://docs/messaging.md","data":{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/messaging.md","title":"resource://docs/messaging.md","uri":"resource://docs/messaging.md"}}
{"kind":"resource/read","uri":"resource://docs/messaging.md","data":{"contents":[{"uri":"resource://docs/messaging.md","mimeType":"text/markdown","text":"# Queue Messaging Workflow\n\nPrimary queue loop:\n1. lockd.queue.enqueue to publish coordination events\n   for large payloads use lockd.queue.write_stream.*\n2. lockd.queue.watch for bounded wakeup signals (recommended for interactive clients)\n3. lockd.queue.dequeue (default queue \"lockd.agent.bus\" unless overridden)\n   payload_mode/state_mode auto =\u003e inline when payload \u003c= lockd.hint.inline_max_payload_bytes, else stream\n   stateful dequeue is all-or-nothing (no partial message-only success when state lease cannot be acquired)\n4. If processing succeeds: lockd.queue.ack\n5. If processing fails: lockd.queue.nack\n6. If message is not for this worker: lockd.queue.defer\n7. If processing runs long: lockd.queue.extend\n\nFor push-notify:\n1. lockd.queue.subscribe\n2. Wait for progress notifications carrying lockd.queue.message_available payload.\n3. Dequeue/ack/defer as above."}]}}
{"kind":"resource","uri":"resource://docs/overview.md","data":{"description":"lockd MCP operational documentation","mimeType":"text/markdown","name":"resource://docs/overview.md","title":"resource://docs/overview.md","uri":"resource://docs/overview.md"}}
{"kind":"resource/read","uri":"resource://docs/overview.md","data":{"contents":[{"uri":"resource://docs/overview.md","mimeType":"text/markdown","text":"# lockd MCP Overview\n\nDefault namespace is \"mcp\" unless callers override `namespace`.\nDefault coordination queue is \"lockd.agent.bus\" in that namespace.\n\nRecommended discovery sequence:\n1. Call lockd.hint for namespace-access hints.\n2. Call lockd.help.\n3. Read resource://docs/messaging.md, resource://docs/agent-sync.md, and resource://docs/lql.md.\n4. Use lockd.query for keys, lockd.query.stream for query documents, and lockd.get for point metadata.\n5. Unless workflow constraints say otherwise, persist a top-level `tags` array on documents (for example [\"planning\",\"finance\",\"q3\"]).\n   No fixed schema fields are required beyond tags; preserve the caller's existing JSON structure.\n6. Use tag-first retrieval and full-text fallback:\n   - in{field=/tags,any=planning|finance}\n   - and.in{field=/tags,any=customer},and.icontains{field=/...,value=renewal}\n   - icontains{field=/...,value=contract}\n7. Use queue tools for agent coordination and messaging.\n8. For large writes, use lockd.*.write_stream.begin to get upload_url, upload bytes directly, optionally call write_stream.status, then commit (optionally with expected_bytes/expected_sha256)."}]}}
{"kind":"resources/templates/list","data":[]}
{"kind":"prompts/list","data":[]}
{"kind":"tool/call","name":"lockd.help","topic":"overview","data":{"content":[{"type":"text","text":"{\"defaults\":{\"namespace\":\"mcp\",\"queue\":\"lockd.agent.bus\"},\"invariants\":[\"run lockd.hint before planning workflows so namespace choices match client claims\",\"queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer\",\"queue.watch is the bounded wake-up primitive for interactive clients\",\"defer preserves message without counting as failure\",\"extend refreshes lease for long-running handlers\",\"inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes\",\"payload_mode/state_mode auto resolves inline when payload \\u003c= lockd.hint.inline_max_payload_bytes, otherwise stream\",\"write_stream.status provides bytes/checksum/readiness before commit\",\"namespace isolation follows client certificate claims\",\"lock writes must preserve lease/fencing semantics\",\"for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes\",\"unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}\",\"no fixed schema fields are required beyond tags; preserve caller-defined document fields\",\"for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision\",\"XA is optional: only include txn_id when coordinating multiple participants\"],\"next_calls\":[\"lockd.hint\",\"lockd.get\",\"lockd.state.stream\",\"lockd.lock.acquire\",\"lockd.state.update\",\"lockd.state.mutate\",\"lockd.state.patch\",\"lockd.state.write_stream.begin\",\"lockd.state.write_stream.status\",\"lockd.attachments.put\",\"lockd.attachments.write_stream.begin\",\"lockd.attachments.write_stream.status\",\"lockd.queue.stats\",\"lockd.queue.enqueue\",\"lockd.queue.write_stream.begin\",\"lockd.queue.write_stream.status\",\"lockd.queue.watch\",\"lockd.queue.dequeue\",\"lockd.queue.ack\",\"lockd.queue.nack\",\"lockd.queue.defer\"],\"resources\":[\"resource://docs/overview.md\",\"resource://docs/lql.md\",\"resource://docs/messaging.md\",\"resource://docs/agent-sync.md\"],\"summary\":\"Start with lockd.hint and lockd.help, use tags-backed state as memory, query with in/icontains patterns, acquire lock when mutating shared state, inspect queue readiness with lockd.queue.stats, use queue.watch for bounded wakeups, then dequeue and ack/nack/defer messages. Use payload_mode inline for small data and stream/write_stream variants for large data.\",\"topic\":\"overview\"}"}],"structuredContent":{"defaults":{"namespace":"mcp","queue":"lockd.agent.bus"},"invariants":["run lockd.hint before planning workflows so namespace choices match client claims","queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer","queue.watch is the bounded wake-up primitive for interactive clients","defer preserves message without counting as failure","extend refreshes lease for long-running handlers","inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes","payload_mode/state_mode auto resolves inline when payload <= lockd.hint.inline_max_payload_bytes, otherwise stream","write_stream.status provides bytes/checksum/readiness before commit","namespace isolation follows client certificate claims","lock writes must preserve lease/fencing semantics","for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes","unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}","no fixed schema fields are required beyond tags; preserve caller-defined document fields","for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision","XA is optional: only include txn_id when coordinating multiple participants"],"next_calls":["lockd.hint","lockd.get","lockd.state.stream","lockd.lock.acquire","lockd.state.update","lockd.state.mutate","lockd.state.patch","lockd.state.write_stream.begin","lockd.state.write_stream.status","lockd.attachments.put","lockd.attachments.write_stream.begin","lockd.attachments.write_stream.status","lockd.queue.stats","lockd.queue.enqueue","lockd.queue.write_stream.begin","lockd.queue.write_stream.status","lockd.queue.watch","lockd.queue.dequeue","lockd.queue.ack","lockd.queue.nack","lockd.queue.defer"],"resources":["resource://docs/overview.md","resource://docs/lql.md","resource://docs/messaging.md","resource://docs/agent-sync.md"],"summary":"Start with lockd.hint and lockd.help, use tags-backed state as memory, query with in/icontains patterns, acquire lock when mutating shared state, inspect queue readiness with lockd.queue.stats, use queue.watch for bounded wakeups, then dequeue and ack/nack/defer messages. Use payload_mode inline for small data and stream/write_stream variants for large data.","topic":"overview"}}}
{"kind":"tool/call","name":"lockd.help","topic":"locks","data":{"content":[{"type":"text","text":"{\"defaults\":{\"namespace\":\"mcp\",\"queue\":\"lockd.agent.bus\"},\"invariants\":[\"run lockd.hint before planning workflows so namespace choices match client claims\",\"queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer\",\"queue.watch is the bounded wake-up primitive for interactive clients\",\"defer preserves message without counting as failure\",\"extend refreshes lease for long-running handlers\",\"inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes\",\"payload_mode/state_mode auto resolves inline when payload \\u003c= lockd.hint.inline_max_payload_bytes, otherwise stream\",\"write_stream.status provides bytes/checksum/readiness before commit\",\"namespace isolation follows client certificate claims\",\"lock writes must preserve lease/fencing semantics\",\"for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes\",\"unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}\",\"no fixed schema fields are required beyond tags; preserve caller-defined document fields\",\"for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision\",\"XA is optional: only include txn_id when coordinating multiple participants\"],\"next_calls\":[\"lockd.hint\",\"lockd.lock.acquire\",\"lockd.state.update\",\"lockd.state.mutate\",\"lockd.state.patch\",\"lockd.state.write_stream.begin\",\"lockd.state.write_stream.status\",\"lockd.attachments.put\",\"lockd.attachments.write_stream.begin\",\"lockd.attachments.write_stream.status\",\"lockd.lock.release\"],\"resources\":[\"resource://docs/locks.md\"],\"summary\":\"Locks gate state mutation; keep lease identity and fencing token through the full mutation lifecycle.\",\"topic\":\"locks\"}"}],"structuredContent":{"defaults":{"namespace":"mcp","queue":"lockd.agent.bus"},"invariants":["run lockd.hint before planning workflows so namespace choices match client claims","queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer","queue.watch is the bounded wake-up primitive for interactive clients","defer preserves message without counting as failure","extend refreshes lease for long-running handlers","inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes","payload_mode/state_mode auto resolves inline when payload <= lockd.hint.inline_max_payload_bytes, otherwise stream","write_stream.status provides bytes/checksum/readiness before commit","namespace isolation follows client certificate claims","lock writes must preserve lease/fencing semantics","for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes","unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}","no fixed schema fields are required beyond tags; preserve caller-defined document fields","for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision","XA is optional: only include txn_id when coordinating multiple participants"],"next_calls":["lockd.hint","lockd.lock.acquire","lockd.state.update","lockd.state.mutate","lockd.state.patch","lockd.state.write_stream.begin","lockd.state.write_stream.status","lockd.attachments.put","lockd.attachments.write_stream.begin","lockd.attachments.write_stream.status","lockd.lock.release"],"resources":["resource://docs/locks.md"],"summary":"Locks gate state mutation; keep lease identity and fencing token through the full mutation lifecycle.","topic":"locks"}}}
{"kind":"tool/call","name":"lockd.help","topic":"messaging","data":{"content":[{"type":"text","text":"{\"defaults\":{\"namespace\":\"mcp\",\"queue\":\"lockd.agent.bus\"},\"invariants\":[\"run lockd.hint before planning workflows so namespace choices match client claims\",\"queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer\",\"queue.watch is the bounded wake-up primitive for interactive clients\",\"defer preserves message without counting as failure\",\"extend refreshes lease for long-running handlers\",\"inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes\",\"payload_mode/state_mode auto resolves inline when payload \\u003c= lockd.hint.inline_max_payload_bytes, otherwise stream\",\"write_stream.status provides bytes/checksum/readiness before commit\",\"namespace isolation follows client certificate claims\",\"lock writes must preserve lease/fencing semantics\",\"for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes\",\"unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}\",\"no fixed schema fields are required beyond tags; preserve caller-defined document fields\",\"for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision\",\"XA is optional: only include txn_id when coordinating multiple participants\"],\"next_calls\":[\"lockd.hint\",\"lockd.queue.stats\",\"lockd.queue.enqueue\",\"lockd.queue.write_stream.begin\",\"lockd.queue.write_stream.status\",\"lockd.queue.watch\",\"lockd.queue.subscribe\",\"lockd.queue.dequeue\",\"lockd.queue.ack\",\"lockd.queue.nack\",\"lockd.queue.defer\",\"lockd.queue.extend\"],\"resources\":[\"resource://docs/messaging.md\"],\"summary\":\"Messaging is dequeue-driven. Use payload_mode=auto/inline/stream on dequeue and state_mode for stateful dequeue state payloads. Use queue.stats for readiness/counters and queue.watch for bounded wakeups, ack success, nack failures, defer when a message is not for this worker, and extend when processing runs long. For large publishes, use queue.write_stream tools.\",\"topic\":\"messaging\"}"}],"structuredContent":{"defaults":{"namespace":"mcp","queue":"lockd.agent.bus"},"invariants":["run lockd.hint before planning workflows so namespace choices match client claims","queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer","queue.watch is the bounded wake-up primitive for interactive clients","defer preserves message without counting as failure","extend refreshes lease for long-running handlers","inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes","payload_mode/state_mode auto resolves inline when payload <= lockd.hint.inline_max_payload_bytes, otherwise stream","write_stream.status provides bytes/checksum/readiness before commit","namespace isolation follows client certificate claims","lock writes must preserve lease/fencing semantics","for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes","unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}","no fixed schema fields are required beyond tags; preserve caller-defined document fields","for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision","XA is optional: only include txn_id when coordinating multiple participants"],"next_calls":["lockd.hint","lockd.queue.stats","lockd.queue.enqueue","lockd.queue.write_stream.begin","lockd.queue.write_stream.status","lockd.queue.watch","lockd.queue.subscribe","lockd.queue.dequeue","lockd.queue.ack","lockd.queue.nack","lockd.queue.defer","lockd.queue.extend"],"resources":["resource://docs/messaging.md"],"summary":"Messaging is dequeue-driven. Use payload_mode=auto/inline/stream on dequeue and state_mode for stateful dequeue state payloads. Use queue.stats for readiness/counters and queue.watch for bounded wakeups, ack success, nack failures, defer when a message is not for this worker, and extend when processing runs long. For large publishes, use queue.write_stream tools.","topic":"messaging"}}}
{"kind":"tool/call","name":"lockd.help","topic":"sync","data":{"content":[{"type":"text","text":"{\"defaults\":{\"namespace\":\"mcp\",\"queue\":\"lockd.agent.bus\"},\"invariants\":[\"run lockd.hint before planning workflows so namespace choices match client claims\",\"queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer\",\"queue.watch is the bounded wake-up primitive for interactive clients\",\"defer preserves message without counting as failure\",\"extend refreshes lease for long-running handlers\",\"inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes\",\"payload_mode/state_mode auto resolves inline when payload \\u003c= lockd.hint.inline_max_payload_bytes, otherwise stream\",\"write_stream.status provides bytes/checksum/readiness before commit\",\"namespace isolation follows client certificate claims\",\"lock writes must preserve lease/fencing semantics\",\"for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes\",\"unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}\",\"no fixed schema fields are required beyond tags; preserve caller-defined document fields\",\"for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision\",\"XA is optional: only include txn_id when coordinating multiple participants\"],\"next_calls\":[\"lockd.hint\",\"lockd.query\",\"lockd.query.stream\",\"lockd.get\",\"lockd.queue.subscribe\"],\"resources\":[\"resource://docs/agent-sync.md\",\"resource://docs/lql.md\",\"resource://docs/overview.md\"],\"summary\":\"Coordinate through queue events and shared state; keep large context in lockd documents with tags arrays for fast in-selector retrieval plus icontains for keyword recall.\",\"topic\":\"sync\"}"}],"structuredContent":{"defaults":{"namespace":"mcp","queue":"lockd.agent.bus"},"invariants":["run lockd.hint before planning workflows so namespace choices match client claims","queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer","queue.watch is the bounded wake-up primitive for interactive clients","defer preserves message without counting as failure","extend refreshes lease for long-running handlers","inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes","payload_mode/state_mode auto resolves inline when payload <= lockd.hint.inline_max_payload_bytes, otherwise stream","write_stream.status provides bytes/checksum/readiness before commit","namespace isolation follows client certificate claims","lock writes must preserve lease/fencing semantics","for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes","unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}","no fixed schema fields are required beyond tags; preserve caller-defined document fields","for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision","XA is optional: only include txn_id when coordinating multiple participants"],"next_calls":["lockd.hint","lockd.query","lockd.query.stream","lockd.get","lockd.queue.subscribe"],"resources":["resource://docs/agent-sync.md","resource://docs/lql.md","resource://docs/overview.md"],"summary":"Coordinate through queue events and shared state; keep large context in lockd documents with tags arrays for fast in-selector retrieval plus icontains for keyword recall.","topic":"sync"}}}
{"kind":"tool/call","name":"lockd.help","topic":"lql","data":{"content":[{"type":"text","text":"{\"defaults\":{\"namespace\":\"mcp\",\"queue\":\"lockd.agent.bus\"},\"invariants\":[\"run lockd.hint before planning workflows so namespace choices match client claims\",\"queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer\",\"queue.watch is the bounded wake-up primitive for interactive clients\",\"defer preserves message without counting as failure\",\"extend refreshes lease for long-running handlers\",\"inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes\",\"payload_mode/state_mode auto resolves inline when payload \\u003c= lockd.hint.inline_max_payload_bytes, otherwise stream\",\"write_stream.status provides bytes/checksum/readiness before commit\",\"namespace isolation follows client certificate claims\",\"lock writes must preserve lease/fencing semantics\",\"for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes\",\"unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}\",\"no fixed schema fields are required beyond tags; preserve caller-defined document fields\",\"for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision\",\"XA is optional: only include txn_id when coordinating multiple participants\"],\"next_calls\":[\"lockd.query\",\"lockd.query.stream\"],\"resources\":[\"resource://docs/lql.md\",\"resource://docs/overview.md\"],\"summary\":\"LQL selectors use JSON Pointer paths and support eq/contains/icontains/prefix/iprefix/range/in/exists plus and/or/not composition, shorthand operators, aliases, and wildcard paths.\",\"topic\":\"lql\"}"}],"structuredContent":{"defaults":{"namespace":"mcp","queue":"lockd.agent.bus"},"invariants":["run lockd.hint before planning workflows so namespace choices match client claims","queue workflow is dequeue (payload_mode inline|stream|auto) then ack/nack/defer","queue.watch is the bounded wake-up primitive for interactive clients","defer preserves message without counting as failure","extend refreshes lease for long-running handlers","inline payloads are capped by mcp.inline_max_bytes; use write_stream tools for larger writes","payload_mode/state_mode auto resolves inline when payload <= lockd.hint.inline_max_payload_bytes, otherwise stream","write_stream.status provides bytes/checksum/readiness before commit","namespace isolation follows client certificate claims","lock writes must preserve lease/fencing semantics","for inline payload_mode requests above the limit, use streaming variants and consult lockd.hint inline_max_payload_bytes","unless workflow-specific policy says otherwise, persist a top-level tags array on documents and query with in{field=/tags,any=planning|finance}","no fixed schema fields are required beyond tags; preserve caller-defined document fields","for broad memory recall, use icontains{field=/...,value=contract} and combine with tag filters for precision","XA is optional: only include txn_id when coordinating multiple participants"],"next_calls":["lockd.query","lockd.query.stream"],"resources":["resource://docs/lql.md","resource://docs/overview.md"],"summary":"LQL selectors use JSON Pointer paths and support eq/contains/icontains/prefix/iprefix/range/in/exists plus and/or/not composition, shorthand operators, aliases, and wildcard paths.","topic":"lql"}}}
