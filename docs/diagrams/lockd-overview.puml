@startuml
' Lockd lease lifecycle overview with storage simplified

skin rose

actor Client
participant "lockd HTTP Handler" as Handler
participant "JSON Compactor" as Compactor
participant "Storage Backend" as Storage

== Acquire ==
Client -> Handler: POST /v1/acquire\n{key, owner, ttl_seconds}
Handler -> Storage: LoadMeta(key)
Storage --> Handler: meta + meta_etag (or empty)
Handler -> Handler: create lease_id\n& fencing_token := meta.fencing+1
Handler -> Storage: StoreMeta(updated lease)\n(expected_etag)
Storage --> Handler: new_meta_etag
Handler --> Client: 200 AcquireResponse\nheaders: X-Fencing-Token, X-Key-Version

== KeepAlive ==
Client -> Handler: POST /v1/keepalive\nlease_id, ttl, X-Fencing-Token
Handler -> Storage: LoadMeta/Validate lease
Handler -> Storage: StoreMeta(updated expires_at)
Storage --> Handler: new_meta_etag
Handler --> Client: 200 KeepAlive\nheader: X-Fencing-Token

== GetState ==
Client -> Handler: POST /v1/get_state\nX-Lease-ID, X-Fencing-Token
Handler -> Storage: ReadState(key)
Storage --> Handler: JSON stream + ETag
Handler --> Client: 200 stream JSON\nheaders: ETag, X-Key-Version, X-Fencing-Token

== UpdateState ==
Client -> Handler: POST /v1/update_state\nbody, CAS headers, X-Fencing-Token
Handler -> Compactor: compact JSON
Compactor --> Handler: canonical stream
Handler -> Storage: WriteState(key)
Storage --> Handler: new_state_etag\n+ bytes_written
Handler -> Storage: StoreMeta(version+1, etag)
Storage --> Handler: new_meta_etag
Handler --> Client: 200 {new_version, new_state_etag, bytes}\nheaders: ETag, X-Key-Version, X-Fencing-Token

== Release ==
Client -> Handler: POST /v1/release\nX-Lease-ID, X-Fencing-Token
Handler -> Storage: StoreMeta(lease cleared)
Storage --> Handler: new_meta_etag
Handler --> Client: 200 {released:true}

@enduml
