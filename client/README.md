<!-- Code generated by go generate; DO NOT EDIT. -->

# Queue API

The queue helpers expose lockd's at-least-once message delivery primitives.
Enqueue a payload by providing a queue name and optional delivery controls.
Any `io.Reader` can be supplied; the SDK streams data directly to the server:

```go
reader := strings.NewReader(`{"op":"ship"}`)
qres, err := cli.Enqueue(ctx, "orders", reader, client.EnqueueOptions{
	ContentType: "application/json",
	Delay:       2 * time.Second,
	Visibility:  30 * time.Second,
})
if err != nil {
	log.Fatal(err)
}
log.Printf("queued message %s", qres.MessageID)

```
Workers call `Dequeue` (stateless) or `DequeueWithState` (message +
workflow state) with their owner identity. The returned handle wraps the
leased message, exposes a streaming payload reader, and tracks the fencing
tokens required for Ack/Nack/Extend:

```go
msg, err := cli.Dequeue(ctx, "orders", client.DequeueOptions{Owner: "worker-1"})
if err != nil {
	log.Fatal(err)
}
defer msg.Close()
buf, err := io.ReadAll(msg)
if err != nil {
	log.Fatal(err)
}
log.Printf("attempt %d payload=%s", msg.Attempts(), string(buf))
// ...do work...
if err := msg.Ack(ctx); err != nil {
	log.Fatal(err)
}

```
The returned message implements `io.ReadCloser` and exposes `Nack` (with
optional delay), `Extend`, `WritePayloadTo`, and a `StateHandle` when using
`DequeueWithState`. The latter mirrors the message APIs and keeps the
workflow state lease in sync when extending or acknowledging the message. If
a caller returns without acking explicitly, the deferred `Close` issues a
nack so another worker can resume. Tune the behaviour via
`DequeueOptions.OnCloseDelay` or `msg.SetOnCloseDelay`. Control how long the
client waits for messages with `DequeueOptions.BlockSeconds`
(`client.BlockNoWait` for immediate return, positive values for bounded
polling).

For higher throughput, use `Subscribe` / `SubscribeWithState` to keep a
single streaming request open and receive deliveries via handler callbacks:

```go
err := cli.Subscribe(ctx, "orders", client.SubscribeOptions{
    Owner:    "worker-1",
    Prefetch: 8,
}, func(ctx context.Context, msg *client.QueueMessage) error {
    defer msg.Close()
    payload, err := io.ReadAll(msg)
    if err != nil {
        return err
    }
    log.Printf("cid=%s payload=%s", msg.CorrelationID(), string(payload))
    return msg.Ack(ctx)
})
if err != nil {
    log.Fatal(err)
}
```

Stateful subscriptions use `SubscribeWithState` and receive both the queue
message and its workflow state handle, mirroring `DequeueWithState`.
Direct request-style helpers (`Client.QueueAck`, `QueueNack`, `QueueExtend`)
are also available when metadata is sourced from environment variables or
other transports.

# State removal

Lease holders can delete JSON state explicitly via
`(*LeaseSession).Remove` or `Client.RemoveState`. CAS headers (If-ETag,
If-Version) are supported to guard against concurrent, stale deletes. When the
state is deleted the server also clears the metadata entry so a subsequent
acquire sees a clean slate.

# Multi-endpoint failover

Builders that point the client at multiple endpoints get deterministic
failover semantics:

```go
cli, err := client.NewWithEndpoints([]string{
    "https://lockd-primary.example.com",
    "https://lockd-backup.example.com",
}, client.WithMTLS(true))

```
The SDK rotates through endpoints when transport errors occur and keeps the
same bounded retry budget as the CLI so tests remain deterministic. When
using mTLS, ensure all endpoints present certificates signed by the same CA.

# Correlation IDs and logging

Use `client.WithCorrelationID` or `client.GenerateCorrelationID` to tag a
context. The client automatically propagates the correlation identifier on
subsequent requests (and logs) so server- and client-side traces can be tied
together. Alternatively, register a logger that implements
`logport.ForLoggingSubset` when constructing the client to capture structured
traces emitted by the SDK.

When working with queues, `QueueMessage.CorrelationID()` exposes the value
assigned at enqueue time, and helpers such as `Ack`, `Nack`, and `Extend`
forward it automatically so DLQ moves and stateful leases remain linked to the
same trace.

# In-process testing

The `client/inprocess` package spins up a lockd server in-process (MTLS
disabled, Unix sockets) and returns a ready-to-use client facade. It is
perfect for unit tests and local experiments:

```go
ctx := context.Background()
inproc, err := inprocess.New(ctx, lockd.Config{Store: "mem://"})
if err != nil {
    t.Fatal(err)
}
defer inproc.Close(ctx)

lease, err := inproc.Acquire(ctx, api.AcquireRequest{Owner: "test", TTLSeconds: 10})
// ...

```
# Authentication and mTLS

By default the client expects mTLS and uses the CA found in the bundle passed
to `client.New`. To connect over plaintext HTTP, construct the client with
`client.WithMTLS(false)` or by using an `http://` endpoint. Clients connecting
over mTLS must present certificates with the `ClientAuth` extended key usage
signed by the same CA as the server certificate.
