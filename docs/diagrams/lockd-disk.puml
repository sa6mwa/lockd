@startuml
' Detailed flow for disk backend

skin rose

actor Client
participant "HTTP Handler" as Handler
participant "Lease Cache" as Cache
participant "Payload Spool" as Spool
participant "disk.Store" as Disk
participant "Global Mutex" as Global
participant "Per-key Mutex" as KeyMutex
participant "File Lock" as FileLock
database "meta/<key>.json" as MetaFile
database "state/<key>/data" as StateData
database "state/<key>/info.json" as StateInfo
database "tmp dir" as TmpDir

== Acquire ==
Client -> Handler: POST /v1/acquire
Handler -> Disk: LoadMeta(key)
Disk -> Global: lock(encoded key)
Global --> Disk: ok
Disk -> KeyMutex: lock(key)
KeyMutex --> Disk: ok
Disk -> FileLock: flock(lock file)
FileLock --> Disk: ok
Disk -> MetaFile: read JSON
MetaFile --> Disk: meta + etag (or ErrNotFound)
Disk -> FileLock: unlock
Disk -> KeyMutex: unlock
Disk -> Global: unlock
Disk --> Handler: meta + meta_etag
Handler -> Handler: lease_id, fencing := prev+1
Handler -> Disk: StoreMeta(updated lease)
Disk -> Global: lock
Disk -> KeyMutex: lock
Disk -> FileLock: flock
Disk -> MetaFile: write temp JSON, fsync, rename
MetaFile --> Disk: new_meta_etag
Disk -> FileLock: unlock
Disk -> KeyMutex: unlock
Disk -> Global: unlock
Disk --> Handler: new_meta_etag
Handler -> Cache: cache snapshot
Handler --> Client: 200 AcquireResponse\nX-Fencing-Token

== KeepAlive ==
Client -> Handler: POST /v1/keepalive\nX-Fencing-Token
Handler -> Cache: lookup lease
alt Cache hit
    Cache --> Handler: meta + etag
else Cache miss
    Handler -> Disk: LoadMeta(key)
    ... (same locking sequence) ...
end
Handler -> Disk: StoreMeta(updated expires_at)
Disk -> Global: lock
Disk -> KeyMutex: lock
Disk -> FileLock: flock
Disk -> MetaFile: write JSON
Disk -> FileLock: unlock
Disk -> KeyMutex: unlock
Disk -> Global: unlock
Disk --> Handler: new_meta_etag
Handler -> Cache: refresh snapshot
Handler --> Client: 200 KeepAlive

== GetState ==
Client -> Handler: POST /v1/get_state
Handler -> Disk: ReadState(key)
Disk -> Global: lock
Disk -> KeyMutex: lock
Disk -> FileLock: flock
Disk -> StateInfo: read info.json
Disk -> StateData: open file read-only
Disk -> FileLock: unlock
Disk -> KeyMutex: unlock
Disk -> Global: unlock
Disk --> Handler: *os.File + info
Handler --> Client: 200 stream\nheaders: ETag, X-Key-Version, X-Fencing-Token

== UpdateState ==
Client -> Handler: POST /v1/update_state
Handler -> Spool: write/compact JSON
Spool --> Handler: io.ReadSeeker
Handler -> Disk: WriteState(key, expected_etag)
Disk -> Global: lock
Disk -> KeyMutex: lock
Disk -> FileLock: flock
Disk -> TmpDir: create temp file
Handler -> Disk: stream body -> temp + sha256
Disk -> TmpDir: fsync & close temp
Disk -> StateData: rename temp -> data
Disk -> StateInfo: write info.json
Disk -> FileLock: unlock
Disk -> KeyMutex: unlock
Disk -> Global: unlock
Disk --> Handler: new_state_etag + bytes
Handler -> Disk: StoreMeta(version+1, state_etag)
Disk -> Global: lock
Disk -> KeyMutex: lock
Disk -> FileLock: flock
Disk -> MetaFile: write JSON
Disk -> FileLock: unlock
Disk -> KeyMutex: unlock
Disk -> Global: unlock
Disk --> Handler: new_meta_etag
Handler -> Cache: update snapshot
Handler --> Client: 200 {new_version, new_state_etag, bytes}\nheaders: ETag, X-Key-Version, X-Fencing-Token

== Release ==
Client -> Handler: POST /v1/release
Handler -> Disk: StoreMeta(lease=nil)
Disk -> Global: lock
Disk -> KeyMutex: lock
Disk -> FileLock: flock
Disk -> MetaFile: write JSON
Disk -> FileLock: unlock
Disk -> KeyMutex: unlock
Disk -> Global: unlock
Disk --> Handler: new_meta_etag
Handler -> Cache: drop lease
Handler --> Client: 200 {released:true}

@enduml
