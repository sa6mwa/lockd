{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "tools": [
      {
        "description": "Purpose: Return persisted plaintext SHA-256 checksum for one attachment without reading attachment payload.\nUse when: You need integrity metadata quickly and cannot afford a full payload read.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required.\nEffects: Returns metadata-derived `plaintext_sha256` for the selected attachment.\nRetry: Safe to retry; this is a read operation.\nNext: Compare against client-side checksum after `lockd.attachments.stream` if payload verification is needed.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "id": {
              "description": "Attachment id selector",
              "type": "string"
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Lease id required when public=false",
              "type": "string"
            },
            "name": {
              "description": "Attachment name selector",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "public": {
              "description": "Read mode selector: true for public read (default), false for lease-bound read",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.checksum",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attachment_id": {
              "type": "string"
            },
            "attachment_name": {
              "type": "string"
            },
            "key": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "plaintext_sha256": {
              "type": "string"
            }
          },
          "required": [
            "namespace",
            "key",
            "attachment_id",
            "attachment_name"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Delete a single attachment under lease protection.\nUse when: One attachment should be removed while keeping others.\nRequires: `key` and `lease_id` are required, plus either `id` or `name`. `namespace` defaults to \"mcp\". Optional `txn_id` enables XA staging.\nEffects: Deletes (or stages deletion of) the targeted attachment and returns success state.\nRetry: Generally safe after network errors; repeated deletes may become no-op/not-found depending on prior success.\nNext: List attachments to verify remaining items, then release lease.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "id": {
              "description": "Attachment id selector",
              "type": "string"
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "name": {
              "description": "Attachment name selector",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.delete",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "deleted": {
              "type": "boolean"
            },
            "version": {
              "type": "integer"
            }
          },
          "required": [
            "deleted",
            "version"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Delete all attachments for a key under lease protection.\nUse when: You need full attachment cleanup for a key.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` allows transactional staging.\nEffects: Removes (or stages removal of) all attachments for the key.\nRetry: Usually safe to retry after transport failures; later attempts may report already-empty state.\nNext: Optionally write replacement attachments, then release lease.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.delete_all",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "deleted": {
              "type": "integer"
            },
            "version": {
              "type": "integer"
            }
          },
          "required": [
            "deleted",
            "version"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Resolve one attachment by id or name and return metadata for streaming decisions.\nUse when: You need attachment metadata and stream hints without loading payload into memory.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. If `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata and persisted checksum only; payload bytes are not returned inline.\nRetry: Safe to retry; this is a read operation.\nNext: Call `lockd.attachments.stream` to get a one-time payload download URL.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "id": {
              "description": "Attachment id selector",
              "type": "string"
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Lease id required when public=false",
              "type": "string"
            },
            "name": {
              "description": "Attachment name selector",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "public": {
              "description": "Read mode selector: true for public read (default), false for lease-bound read",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.get",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attachment": {
              "additionalProperties": false,
              "properties": {
                "content_type": {
                  "type": "string"
                },
                "created_at_unix": {
                  "type": "integer"
                },
                "id": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "plaintext_sha256": {
                  "type": "string"
                },
                "size": {
                  "type": "integer"
                },
                "updated_at_unix": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "name",
                "size"
              ],
              "type": "object"
            },
            "key": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "payload_bytes": {
              "type": "integer"
            },
            "payload_sha256": {
              "type": "string"
            },
            "stream_required": {
              "type": "boolean"
            }
          },
          "required": [
            "namespace",
            "key",
            "attachment",
            "payload_bytes",
            "stream_required"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Fetch metadata for one attachment by id or name without reading payload bytes.\nUse when: You need to inspect attachment existence/size/type before deciding whether to download content.\nRequires: `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. If `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata only (`id`, `name`, `size`, `plaintext_sha256`, timestamps, and content type).\nRetry: Safe to retry; this is a read operation.\nNext: Call `lockd.attachments.stream` when payload content is required.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "id": {
              "description": "Attachment id selector",
              "type": "string"
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Lease id required when public=false",
              "type": "string"
            },
            "name": {
              "description": "Attachment name selector",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "public": {
              "description": "Read mode selector: true for public read (default), false for lease-bound read",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.head",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attachment": {
              "additionalProperties": false,
              "properties": {
                "content_type": {
                  "type": "string"
                },
                "created_at_unix": {
                  "type": "integer"
                },
                "id": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "plaintext_sha256": {
                  "type": "string"
                },
                "size": {
                  "type": "integer"
                },
                "updated_at_unix": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "name",
                "size"
              ],
              "type": "object"
            },
            "key": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "namespace",
            "key",
            "attachment"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: List attachment metadata for a key.\nUse when: You need attachment ids/names before get/delete workflows.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. If `public=true`, `lease_id` must be omitted.\nEffects: Returns attachment metadata only (no payload bytes).\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.attachments.head` for metadata-only lookup, `lockd.attachments.get` for payload access, or delete tools for cleanup.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Lease id required when public=false",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "public": {
              "description": "Read mode selector: true for public read (default), false for lease-bound read",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.list",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attachments": {
              "items": {
                "additionalProperties": false,
                "properties": {
                  "content_type": {
                    "type": "string"
                  },
                  "created_at_unix": {
                    "type": "integer"
                  },
                  "id": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  },
                  "plaintext_sha256": {
                    "type": "string"
                  },
                  "size": {
                    "type": "integer"
                  },
                  "updated_at_unix": {
                    "type": "integer"
                  }
                },
                "required": [
                  "id",
                  "name",
                  "size"
                ],
                "type": "object"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "key": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "namespace",
            "key",
            "attachments"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Create a one-time download capability URL for attachment payload bytes.\nUse when: You need attachment content without pushing payload through MCP tool responses.\nRequires: Active MCP session is required. `key` plus either `id` or `name` is required. `namespace` defaults to \"mcp\". `public` defaults to true.\nEffects: Returns attachment metadata plus one-time `download_url` and `download_method` for direct HTTP download.\nRetry: Safe to retry; each call creates a new one-time URL.\nNext: Fetch `download_url` directly and compare with `lockd.attachments.checksum` when integrity checks are needed.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "id": {
              "description": "Attachment id selector",
              "type": "string"
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Lease id required when public=false",
              "type": "string"
            },
            "name": {
              "description": "Attachment name selector",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "public": {
              "description": "Read mode selector: true for public read (default), false for lease-bound read",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.stream",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attachment": {
              "additionalProperties": false,
              "properties": {
                "content_type": {
                  "type": "string"
                },
                "created_at_unix": {
                  "type": "integer"
                },
                "id": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "plaintext_sha256": {
                  "type": "string"
                },
                "size": {
                  "type": "integer"
                },
                "updated_at_unix": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "name",
                "size"
              ],
              "type": "object"
            },
            "download_expires_at_unix": {
              "type": "integer"
            },
            "download_method": {
              "type": "string"
            },
            "download_url": {
              "type": "string"
            },
            "key": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "namespace",
            "key",
            "attachment"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Abort an in-flight attachment write stream.\nUse when: Attachment upload should be canceled.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates upload flow and frees stream resources.\nRetry: Safe to retry; absent streams return not-found style errors.\nNext: Begin a new attachment stream if upload should be retried.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "reason": {
              "description": "Optional abort reason for diagnostics",
              "type": "string"
            },
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.write_stream.abort",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "aborted": {
              "type": "boolean"
            },
            "bytes_received": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "aborted",
            "bytes_received"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Append one base64 chunk into an open attachment write stream.\nUse when: You are uploading attachment bytes chunk-by-chunk.\nRequires: Active MCP session is required. `stream_id` and `chunk_base64` are required. Decoded chunk must be \u003c= 2097152 bytes.\nEffects: Writes chunk bytes directly to upstream attachment body stream and returns append/total byte counts.\nRetry: Do not blindly retry the same chunk without stream-position tracking; repeated append can duplicate bytes.\nNext: Continue appending until complete, then `lockd.attachments.write_stream.commit`.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "chunk_base64": {
              "description": "Base64-encoded payload chunk bytes",
              "type": "string"
            },
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "chunk_base64"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.write_stream.append",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "bytes_appended": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            },
            "total_bytes": {
              "type": "integer"
            }
          },
          "required": [
            "stream_id",
            "bytes_appended",
            "total_bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Open a session-scoped streaming attachment writer.\nUse when: You need to upload attachment payloads (all attachment writes are stream-based).\nRequires: Active MCP session is required. `key`, `lease_id`, and `name` are required. `namespace` defaults to \"mcp\". `mode` supports `create` (default), `upsert`, `replace`.\nEffects: Creates a stream session and returns one-time `upload_url` for direct HTTP PUT upload into upstream attachment flow.\nRetry: Not idempotent; begin returns a new stream each time. Abort unused streams explicitly.\nNext: Upload bytes to `upload_url`, then call `lockd.attachments.write_stream.commit` (or `abort`).",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "content_type": {
              "description": "Attachment content type",
              "type": "string"
            },
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "max_bytes": {
              "description": "Optional upload size cap",
              "type": "integer"
            },
            "mode": {
              "description": "Write mode: create (default), upsert, or replace",
              "type": "string"
            },
            "name": {
              "description": "Attachment name",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id",
            "name"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.write_stream.begin",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "max_chunk_bytes": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            },
            "upload_expires_at_unix": {
              "type": "integer"
            },
            "upload_method": {
              "type": "string"
            },
            "upload_url": {
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "max_chunk_bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Finalize an attachment write stream.\nUse when: All attachment payload chunks have been appended.\nRequires: Active MCP session and `stream_id` are required.\nEffects: Closes the upload stream, waits for upstream attach completion, and returns attachment metadata/version.\nRetry: Commit is terminal for a stream_id. On failure, begin a new stream and replay payload.\nNext: List/head/checksum attachments for verification, then release lease.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id"
          ],
          "type": "object"
        },
        "name": "lockd.attachments.write_stream.commit",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attachment": {
              "additionalProperties": false,
              "properties": {
                "content_type": {
                  "type": "string"
                },
                "created_at_unix": {
                  "type": "integer"
                },
                "id": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "plaintext_sha256": {
                  "type": "string"
                },
                "size": {
                  "type": "integer"
                },
                "updated_at_unix": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "name",
                "size"
              ],
              "type": "object"
            },
            "bytes_received": {
              "type": "integer"
            },
            "noop": {
              "type": "boolean"
            },
            "stream_id": {
              "type": "string"
            },
            "version": {
              "type": "integer"
            }
          },
          "required": [
            "stream_id",
            "bytes_received",
            "attachment",
            "noop",
            "version"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Read key metadata (lease owner, version, ETag, timestamps) without returning state payload.\nUse when: You need lock/version metadata for diagnostics, conflict handling, or coordination checks.\nRequires: `key` is required. `namespace` defaults to \"mcp\" when omitted.\nEffects: Returns metadata snapshot only; does not mutate state.\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.get` to read payload or lock tools for mutation workflows.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "key": {
              "description": "Lock key to inspect",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.describe",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "expires_at_unix": {
              "type": "integer"
            },
            "key": {
              "type": "string"
            },
            "lease_id": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "query_hidden": {
              "type": [
                "null",
                "boolean"
              ]
            },
            "state_etag": {
              "type": "string"
            },
            "updated_at_unix": {
              "type": "integer"
            },
            "version": {
              "type": "integer"
            }
          },
          "required": [
            "namespace",
            "key",
            "version"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Read committed JSON state for one key.\nUse when: You need current state for planning, validation, or rendering context.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true. If `public=false`, `lease_id` is required. If `public=true`, `lease_id` must be omitted.\nEffects: Returns metadata only (`found`, ETag, numeric version). Payload is never inlined; use `lockd.state.stream` when content is required.\nRetry: Safe to retry; this is a read operation.\nNext: Call `lockd.state.stream` for payload bytes, `lockd.query` for broader discovery, or acquire a lock before mutation.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "key": {
              "description": "Lock key to read",
              "type": "string"
            },
            "lease_id": {
              "description": "Lease ID required when public=false",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "public": {
              "description": "Read mode selector: true for public read (default), false for lease-bound read",
              "type": [
                "null",
                "boolean"
              ]
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.get",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "etag": {
              "type": "string"
            },
            "found": {
              "type": "boolean"
            },
            "key": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "stream_required": {
              "type": "boolean"
            },
            "version": {
              "type": "integer"
            }
          },
          "required": [
            "namespace",
            "key",
            "found",
            "stream_required"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Return curated lockd MCP workflows, invariants, and documentation resource URIs.\nUse when: Start of session or when uncertain about correct operation sequence.\nRequires: No required fields. Optional `topic` narrows guidance to overview/locks/messaging/sync.\nEffects: Returns guidance only; no lockd state mutation occurs.\nRetry: Safe to retry.\nNext: Follow `next_calls` in the response, typically beginning with lock, queue, or query tools.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "topic": {
              "description": "Optional topic: overview, locks, messaging, sync",
              "type": "string"
            }
          },
          "type": "object"
        },
        "name": "lockd.help",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "defaults": {
              "additionalProperties": {
                "type": "string"
              },
              "type": "object"
            },
            "invariants": {
              "items": {
                "type": "string"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "next_calls": {
              "items": {
                "type": "string"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "resources": {
              "items": {
                "type": "string"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "summary": {
              "type": "string"
            },
            "topic": {
              "type": "string"
            }
          },
          "required": [
            "topic",
            "summary",
            "next_calls",
            "resources",
            "defaults",
            "invariants"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Return namespace access hints so agents can choose valid namespaces before doing work.\nUse when: Session start, planning phase, or when namespace-forbidden errors occur.\nRequires: No required fields. Uses current caller token context plus upstream client-bundle namespace claims when available.\nEffects: Returns advisory namespace access hints, default namespace, client id, and token scope context.\nRetry: Safe to retry; this is a read-only advisory operation.\nNext: Call `lockd.help` then use returned namespace hints when invoking lock/query/queue tools.",
        "inputSchema": {
          "additionalProperties": false,
          "type": "object"
        },
        "name": "lockd.hint",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "claim_uris": {
              "items": {
                "type": "string"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "client_id": {
              "type": "string"
            },
            "default_namespace": {
              "type": "string"
            },
            "namespace_hints": {
              "items": {
                "additionalProperties": false,
                "properties": {
                  "namespace": {
                    "type": "string"
                  },
                  "permission": {
                    "type": "string"
                  }
                },
                "required": [
                  "namespace",
                  "permission"
                ],
                "type": "object"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "notes": {
              "items": {
                "type": "string"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "source": {
              "type": "string"
            },
            "token_scopes": {
              "items": {
                "type": "string"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "wildcard_permission": {
              "type": "string"
            }
          },
          "required": [
            "default_namespace",
            "source"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Trigger search index flush for a namespace.\nUse when: You need query index freshness guarantees after heavy writes or before time-sensitive reads.\nRequires: `namespace` defaults to \"mcp\". `mode` may be `async` (default) or `wait`.\nEffects: Schedules or waits for index flush and returns flush progress metadata.\nRetry: Safe to retry; repeated flush requests are operationally benign.\nNext: Run `lockd.query` to observe refreshed index results.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "mode": {
              "description": "Flush mode: async (default) or wait",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            }
          },
          "type": "object"
        },
        "name": "lockd.index.flush",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "accepted": {
              "type": "boolean"
            },
            "flush_id": {
              "type": "string"
            },
            "flushed": {
              "type": "boolean"
            },
            "index_seq": {
              "minimum": 0,
              "type": "integer"
            },
            "mode": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "pending": {
              "type": "boolean"
            }
          },
          "required": [
            "namespace",
            "mode",
            "accepted",
            "flushed",
            "pending"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Acquire an exclusive lock lease and receive the lease identity/fencing material needed for protected writes.\nUse when: You need to mutate shared state or attachments for a key, or you need exclusive coordination ownership.\nRequires: `key` is required. `namespace` defaults to \"mcp\". `owner` defaults to OAuth client id. Optional `txn_id` enlists the lease in XA flow.\nEffects: Creates or claims a lease and returns `lease_id`, `fencing_token`, expiry, and optional `txn_id` for follow-up tools.\nRetry: Not inherently idempotent. Retry can obtain a different lease or block outcome; use deterministic owner/workflow guards.\nNext: Call `lockd.state.update` or attachment tools, keep lease alive while working, then `lockd.lock.release`.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "block_seconds": {
              "description": "Acquire wait: -1 no wait, 0 wait forever, \u003e0 wait seconds",
              "type": "integer"
            },
            "if_not_exists": {
              "description": "Create-only acquire",
              "type": "boolean"
            },
            "key": {
              "description": "Key to lock",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "owner": {
              "description": "Lock owner (defaults to oauth client id)",
              "type": "string"
            },
            "ttl_seconds": {
              "description": "Lease TTL in seconds",
              "type": "integer"
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.lock.acquire",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "correlation_id": {
              "type": "string"
            },
            "expires_at_unix": {
              "type": "integer"
            },
            "fencing_token": {
              "type": "integer"
            },
            "key": {
              "type": "string"
            },
            "lease_id": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "state_etag": {
              "type": "string"
            },
            "txn_id": {
              "type": "string"
            },
            "version": {
              "type": "integer"
            }
          },
          "required": [
            "namespace",
            "key",
            "lease_id",
            "owner",
            "expires_at_unix",
            "version"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Extend an active lock lease TTL.\nUse when: Long-running work might outlive current lease expiry.\nRequires: `key`, `lease_id`, and `ttl_seconds \u003e 0` are required. `namespace` defaults to \"mcp\". Optional `txn_id` keeps XA context consistent.\nEffects: Extends lease expiry and returns the updated expiration timestamp.\nRetry: Safe to retry while lease is still valid. If lease already expired, reacquire with `lockd.lock.acquire`.\nNext: Continue mutation workflow; periodically keepalive until ready to release.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "key": {
              "description": "Locked key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "ttl_seconds": {
              "description": "TTL extension in seconds",
              "type": "integer"
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id",
            "ttl_seconds"
          ],
          "type": "object"
        },
        "name": "lockd.lock.keepalive",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "expires_at_unix": {
              "type": "integer"
            }
          },
          "required": [
            "expires_at_unix"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Release a lease and finalize staged changes.\nUse when: Work under a lease is complete or must be abandoned.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` and `rollback=true` control XA/rollback behavior.\nEffects: Releases lease ownership. Commits staged changes by default; rolls back when `rollback=true`.\nRetry: Usually safe to retry after transport failures; duplicate release may return already-released/lease errors depending on timing.\nNext: If more work is needed later, reacquire with `lockd.lock.acquire`.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "key": {
              "description": "Locked key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "rollback": {
              "description": "Rollback staged changes instead of commit",
              "type": "boolean"
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id"
          ],
          "type": "object"
        },
        "name": "lockd.lock.release",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "released": {
              "type": "boolean"
            }
          },
          "required": [
            "released"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Read namespace query-engine configuration.\nUse when: You need to inspect current query engine settings before updates or debugging.\nRequires: `namespace` defaults to \"mcp\" when omitted.\nEffects: Returns effective namespace query configuration and ETag context.\nRetry: Safe to retry; this is a read operation.\nNext: Use `lockd.namespace.update` to change engine preferences.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            }
          },
          "type": "object"
        },
        "name": "lockd.namespace.get",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "etag": {
              "type": "string"
            },
            "fallback_engine": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "preferred_engine": {
              "type": "string"
            }
          },
          "required": [
            "namespace",
            "preferred_engine",
            "fallback_engine"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Update namespace query-engine configuration.\nUse when: You need to change preferred/fallback query engines for a namespace.\nRequires: `preferred_engine` and `fallback_engine` are required. `namespace` defaults to \"mcp\". Optional `if_match` enables CAS-safe updates.\nEffects: Persists namespace query config and returns updated values/ETag.\nRetry: Prefer `if_match` for deterministic retries; otherwise concurrent updates may overwrite each other.\nNext: Optionally call `lockd.index.flush` or rerun queries to validate behavior.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fallback_engine": {
              "description": "Fallback query engine",
              "type": "string"
            },
            "if_match": {
              "description": "Optional If-Match ETag for CAS updates",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "preferred_engine": {
              "description": "Preferred query engine",
              "type": "string"
            }
          },
          "required": [
            "preferred_engine",
            "fallback_engine"
          ],
          "type": "object"
        },
        "name": "lockd.namespace.update",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "etag": {
              "type": "string"
            },
            "fallback_engine": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "preferred_engine": {
              "type": "string"
            }
          },
          "required": [
            "namespace",
            "preferred_engine",
            "fallback_engine"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Run LQL queries over namespace data in key mode.\nUse when: You need to locate candidate keys before reading or locking.\nRequires: `query` expression is required. `namespace` defaults to \"mcp\". Optional `limit`, `cursor`, `engine`, `refresh`, and `fields` refine execution. Query output is always keys.\nEffects: Returns matching keys plus pagination/index metadata (`cursor`, `index_seq`).\nRetry: Safe to retry. Cursor-based pagination should reuse the latest returned cursor.\nNext: Call `lockd.query.stream` for document payload streaming, or `lockd.get` and `lockd.state.stream` for point reads.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "cursor": {
              "description": "Continuation cursor",
              "type": "string"
            },
            "engine": {
              "description": "Optional query engine override: auto, index, or scan",
              "type": "string"
            },
            "fields": {
              "additionalProperties": true,
              "description": "Optional query field projection map",
              "type": "object"
            },
            "limit": {
              "description": "Maximum rows to return",
              "type": "integer"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "query": {
              "description": "LQL query expression",
              "type": "string"
            },
            "refresh": {
              "description": "Optional refresh policy, for example wait_for",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "type": "object"
        },
        "name": "lockd.query",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "cursor": {
              "type": "string"
            },
            "index_seq": {
              "minimum": 0,
              "type": "integer"
            },
            "keys": {
              "items": {
                "type": "string"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "metadata": {
              "additionalProperties": {
                "type": "string"
              },
              "type": "object"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "namespace"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Run an LQL query and stream matching documents over MCP progress notifications without buffering full result sets.\nUse when: You need query result documents and must keep MCP memory usage bounded.\nRequires: Active MCP session is required. `query` expression is required. `namespace` defaults to \"mcp\". Optional `limit`, `cursor`, `engine`, `refresh`, `fields`, `chunk_bytes`, `max_bytes`, and `max_documents` bound execution.\nEffects: Emits `lockd.query.document.chunk` progress notifications per document chunk and returns stream summary (`documents_streamed`, `streamed_bytes`, `chunks`, `truncated`).\nRetry: Safe to retry; each call restarts the query stream from the provided cursor/options.\nNext: Use returned `cursor` for pagination and verify document processing before issuing the next page.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "chunk_bytes": {
              "description": "Chunk size per progress event in bytes (default 65536, max 4194304)",
              "type": "integer"
            },
            "cursor": {
              "description": "Continuation cursor",
              "type": "string"
            },
            "engine": {
              "description": "Optional query engine override: auto, index, or scan",
              "type": "string"
            },
            "fields": {
              "additionalProperties": true,
              "description": "Optional query field projection map",
              "type": "object"
            },
            "limit": {
              "description": "Maximum rows to return",
              "type": "integer"
            },
            "max_bytes": {
              "description": "Optional maximum bytes to stream before truncating",
              "type": "integer"
            },
            "max_documents": {
              "description": "Optional maximum documents to stream before truncating",
              "type": "integer"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "progress_token": {
              "description": "Optional explicit progress token for chunk notifications",
              "type": "string"
            },
            "query": {
              "description": "LQL query expression",
              "type": "string"
            },
            "refresh": {
              "description": "Optional refresh policy, for example wait_for",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "type": "object"
        },
        "name": "lockd.query.stream",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "chunks": {
              "type": "integer"
            },
            "cursor": {
              "type": "string"
            },
            "documents_streamed": {
              "type": "integer"
            },
            "index_seq": {
              "minimum": 0,
              "type": "integer"
            },
            "metadata": {
              "additionalProperties": {
                "type": "string"
              },
              "type": "object"
            },
            "namespace": {
              "type": "string"
            },
            "progress_token": {
              "type": "string"
            },
            "stop_reason": {
              "type": "string"
            },
            "streamed_bytes": {
              "type": "integer"
            },
            "truncated": {
              "type": "boolean"
            }
          },
          "required": [
            "namespace",
            "progress_token",
            "documents_streamed",
            "streamed_bytes",
            "chunks",
            "truncated"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Acknowledge successful processing of a dequeued message.\nUse when: Worker completed handling of a leased message.\nRequires: `queue`, `message_id`, `lease_id`, `fencing_token`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Use fields returned by `lockd.queue.dequeue`.\nEffects: Confirms processing and removes/commits message state according to lockd queue semantics.\nRetry: Generally safe after network failures; duplicate ack may return already-acknowledged/mismatch errors based on lease state.\nNext: Dequeue next message or perform follow-up state updates as needed.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Dequeued fencing token",
              "type": "integer"
            },
            "lease_id": {
              "description": "Dequeued lease id",
              "type": "string"
            },
            "message_id": {
              "description": "Dequeued message id",
              "type": "string"
            },
            "meta_etag": {
              "description": "Dequeued meta etag",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name",
              "type": "string"
            },
            "state_etag": {
              "description": "Optional state etag",
              "type": "string"
            },
            "state_fencing_token": {
              "description": "Optional state fencing token",
              "type": "integer"
            },
            "state_lease_id": {
              "description": "Optional state lease id",
              "type": "string"
            },
            "txn_id": {
              "description": "Optional transaction id",
              "type": "string"
            }
          },
          "required": [
            "queue",
            "message_id",
            "lease_id",
            "fencing_token",
            "meta_etag"
          ],
          "type": "object"
        },
        "name": "lockd.queue.ack",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "acked": {
              "type": "boolean"
            },
            "correlation_id": {
              "type": "string"
            }
          },
          "required": [
            "acked"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Requeue a leased message intentionally without counting it as failure.\nUse when: Message is valid but should be processed later or by another worker.\nRequires: `queue`, `message_id`, `lease_id`, `fencing_token`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Optional `delay_seconds` postpones visibility.\nEffects: Returns message to queue with defer intent and optional delay.\nRetry: Generally safe after transport failures; repeated defer can change next-visibility timing.\nNext: Continue polling/subscription workflow and dequeue again when ready.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "delay_seconds": {
              "description": "Visibility delay before message becomes available again",
              "type": "integer"
            },
            "fencing_token": {
              "description": "Dequeued fencing token",
              "type": "integer"
            },
            "lease_id": {
              "description": "Dequeued lease id",
              "type": "string"
            },
            "message_id": {
              "description": "Dequeued message id",
              "type": "string"
            },
            "meta_etag": {
              "description": "Dequeued meta etag",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name",
              "type": "string"
            },
            "state_etag": {
              "description": "Optional state etag",
              "type": "string"
            },
            "state_fencing_token": {
              "description": "Optional state fencing token",
              "type": "integer"
            },
            "state_lease_id": {
              "description": "Optional state lease id",
              "type": "string"
            },
            "txn_id": {
              "description": "Optional transaction id",
              "type": "string"
            }
          },
          "required": [
            "queue",
            "message_id",
            "lease_id",
            "fencing_token",
            "meta_etag"
          ],
          "type": "object"
        },
        "name": "lockd.queue.defer",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "correlation_id": {
              "type": "string"
            },
            "meta_etag": {
              "type": "string"
            },
            "requeued": {
              "type": "boolean"
            }
          },
          "required": [
            "requeued"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Receive one available message lease from a queue.\nUse when: A worker is ready to process the next queue item.\nRequires: Active MCP session is required for payload transfer. `queue` defaults to \"lockd.agent.bus\". `namespace` defaults to \"mcp\". `owner` defaults to OAuth client id. Optional `stateful`, `visibility_seconds`, `cursor`, and `txn_id` tune dequeue behavior.\nEffects: Returns `found=false` when no message is available, or message metadata/lease fields plus one-time `payload_download_url` for direct payload download. Includes `next_cursor` for continuation.\nRetry: Safe to retry. Duplicate retries may lease different messages when queue state changes.\nNext: Download payload with returned URL/method, then call `lockd.queue.ack`, `lockd.queue.nack`, or `lockd.queue.defer`; use `lockd.queue.extend` for long handlers.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "block_seconds": {
              "description": "Long-poll wait; -1 no wait, 0 wait forever, \u003e0 wait seconds",
              "type": "integer"
            },
            "cursor": {
              "description": "Optional continuation cursor from previous dequeue response",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "owner": {
              "description": "Consumer owner ID (defaults to oauth client id)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name (defaults to lockd.agent.bus)",
              "type": "string"
            },
            "stateful": {
              "description": "Acquire workflow state lease alongside dequeued message",
              "type": "boolean"
            },
            "txn_id": {
              "description": "Optional transaction id to bind dequeue operations",
              "type": "string"
            },
            "visibility_seconds": {
              "description": "Optional visibility timeout override in seconds",
              "type": "integer"
            }
          },
          "type": "object"
        },
        "name": "lockd.queue.dequeue",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attempts": {
              "type": "integer"
            },
            "content_type": {
              "type": "string"
            },
            "correlation_id": {
              "type": "string"
            },
            "failure_attempts": {
              "type": "integer"
            },
            "fencing_token": {
              "type": "integer"
            },
            "found": {
              "type": "boolean"
            },
            "lease_expires_at_unix": {
              "type": "integer"
            },
            "lease_id": {
              "type": "string"
            },
            "max_attempts": {
              "type": "integer"
            },
            "message_id": {
              "type": "string"
            },
            "meta_etag": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "next_cursor": {
              "type": "string"
            },
            "not_visible_until_unix": {
              "type": "integer"
            },
            "payload_bytes": {
              "type": "integer"
            },
            "payload_download_expires_at_unix": {
              "type": "integer"
            },
            "payload_download_method": {
              "type": "string"
            },
            "payload_download_url": {
              "type": "string"
            },
            "queue": {
              "type": "string"
            },
            "state_etag": {
              "type": "string"
            },
            "state_fencing_token": {
              "type": "integer"
            },
            "state_lease_expires_at_unix": {
              "type": "integer"
            },
            "state_lease_id": {
              "type": "string"
            },
            "txn_id": {
              "type": "string"
            },
            "visibility_timeout_seconds": {
              "type": "integer"
            }
          },
          "required": [
            "namespace",
            "queue",
            "found"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Publish a message to a lockd queue for agent coordination.\nUse when: You need to signal work/events/context to queue consumers and payload fits inline limits.\nRequires: `queue` defaults to \"lockd.agent.bus\". `namespace` defaults to \"mcp\". Provide payload via exactly one of `payload_text` or `payload_base64`; decoded payload must be \u003c= 2097152 bytes.\nEffects: Appends a queue message and returns delivery metadata (`message_id`, visibility, attempts). Queue ordering is best-effort under retries/requeues; do not assume strict FIFO across all consumers.\nRetry: Not idempotent by default; retries can enqueue duplicates. Use application-level dedupe keys in payload/attributes.\nNext: For larger payloads use `lockd.queue.write_stream.begin` and upload to returned `upload_url`, then `commit`. Consumers should dequeue then ack/nack/defer.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "attributes": {
              "additionalProperties": true,
              "description": "Message attributes metadata",
              "type": "object"
            },
            "content_type": {
              "description": "Payload content type",
              "type": "string"
            },
            "delay_seconds": {
              "description": "Initial invisibility delay",
              "type": "integer"
            },
            "max_attempts": {
              "description": "Maximum failed attempts before terminal handling",
              "type": "integer"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "payload_base64": {
              "description": "Base64-encoded payload bytes",
              "type": "string"
            },
            "payload_text": {
              "description": "UTF-8 payload text",
              "type": "string"
            },
            "queue": {
              "description": "Queue name (defaults to lockd.agent.bus)",
              "type": "string"
            },
            "ttl_seconds": {
              "description": "Message retention TTL in seconds",
              "type": "integer"
            },
            "visibility_seconds": {
              "description": "Visibility timeout for dequeued lease",
              "type": "integer"
            }
          },
          "type": "object"
        },
        "name": "lockd.queue.enqueue",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attempts": {
              "type": "integer"
            },
            "correlation_id": {
              "type": "string"
            },
            "failure_attempts": {
              "type": "integer"
            },
            "max_attempts": {
              "type": "integer"
            },
            "message_id": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "not_visible_until_unix": {
              "type": "integer"
            },
            "payload_bytes": {
              "type": "integer"
            },
            "queue": {
              "type": "string"
            },
            "visibility_timeout_seconds": {
              "type": "integer"
            }
          },
          "required": [
            "namespace",
            "queue",
            "message_id",
            "attempts",
            "max_attempts",
            "not_visible_until_unix",
            "visibility_timeout_seconds",
            "payload_bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Extend visibility/lease timeout for a currently leased queue message.\nUse when: Message processing is still active and lease timeout is approaching.\nRequires: `queue`, `message_id`, `lease_id`, `fencing_token`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Optional state lease fields support stateful dequeue workflows.\nEffects: Refreshes message lease expiry and visibility timeout; returns updated lease timing and metadata ETag.\nRetry: Safe to retry while lease remains valid. If lease has expired, dequeue again to reacquire.\nNext: Continue processing, then ack/nack/defer when work is complete.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "extend_by_seconds": {
              "description": "Lease extension in seconds",
              "type": "integer"
            },
            "fencing_token": {
              "description": "Dequeued fencing token",
              "type": "integer"
            },
            "lease_id": {
              "description": "Dequeued lease id",
              "type": "string"
            },
            "message_id": {
              "description": "Dequeued message id",
              "type": "string"
            },
            "meta_etag": {
              "description": "Dequeued meta etag",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name",
              "type": "string"
            },
            "state_fencing_token": {
              "description": "Optional state fencing token",
              "type": "integer"
            },
            "state_lease_id": {
              "description": "Optional state lease id",
              "type": "string"
            },
            "txn_id": {
              "description": "Optional transaction id",
              "type": "string"
            }
          },
          "required": [
            "queue",
            "message_id",
            "lease_id",
            "fencing_token",
            "meta_etag"
          ],
          "type": "object"
        },
        "name": "lockd.queue.extend",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "correlation_id": {
              "type": "string"
            },
            "lease_expires_at_unix": {
              "type": "integer"
            },
            "meta_etag": {
              "type": "string"
            },
            "state_lease_expires_at_unix": {
              "type": "integer"
            },
            "visibility_timeout_seconds": {
              "type": "integer"
            }
          },
          "required": [
            "lease_expires_at_unix",
            "visibility_timeout_seconds"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Requeue a message as a failure, consuming failure budget (`max_attempts`).\nUse when: Message processing failed and should be retried later with failure semantics.\nRequires: `queue`, `message_id`, `lease_id`, `fencing_token`, and `meta_etag` are required. `namespace` defaults to \"mcp\". Optional `delay_seconds` and `reason` enrich retry behavior.\nEffects: Requeues message with `intent=failure`, updates queue metadata ETag, and records optional failure detail.\nRetry: Generally safe after transport failures; repeated nack can alter delay/attempt metadata depending on timing.\nNext: Dequeue next message or inspect retry/dead-letter behavior.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "delay_seconds": {
              "description": "Visibility delay before message becomes available again",
              "type": "integer"
            },
            "fencing_token": {
              "description": "Dequeued fencing token",
              "type": "integer"
            },
            "lease_id": {
              "description": "Dequeued lease id",
              "type": "string"
            },
            "message_id": {
              "description": "Dequeued message id",
              "type": "string"
            },
            "meta_etag": {
              "description": "Dequeued meta etag",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name",
              "type": "string"
            },
            "reason": {
              "description": "Optional failure reason detail",
              "type": "string"
            },
            "state_etag": {
              "description": "Optional state etag",
              "type": "string"
            },
            "state_fencing_token": {
              "description": "Optional state fencing token",
              "type": "integer"
            },
            "state_lease_id": {
              "description": "Optional state lease id",
              "type": "string"
            },
            "txn_id": {
              "description": "Optional transaction id",
              "type": "string"
            }
          },
          "required": [
            "queue",
            "message_id",
            "lease_id",
            "fencing_token",
            "meta_etag"
          ],
          "type": "object"
        },
        "name": "lockd.queue.nack",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "correlation_id": {
              "type": "string"
            },
            "meta_etag": {
              "type": "string"
            },
            "requeued": {
              "type": "boolean"
            }
          },
          "required": [
            "requeued"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Read side-effect-free queue runtime stats and current visible head snapshot.\nUse when: You need queue health/introspection signals before deciding whether to watch/dequeue.\nRequires: `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Returns dispatcher counters (`waiting_consumers`, `pending_candidates`, `total_consumers`), watcher state (`has_active_watcher`), and head availability fields when a visible message exists.\nRetry: Safe to retry; read-only operation.\nNext: Use `lockd.queue.watch` for bounded wakeups and `lockd.queue.dequeue` for actual message leasing/consumption.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name (defaults to lockd.agent.bus)",
              "type": "string"
            }
          },
          "type": "object"
        },
        "name": "lockd.queue.stats",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "available": {
              "type": "boolean"
            },
            "correlation_id": {
              "type": "string"
            },
            "has_active_watcher": {
              "type": "boolean"
            },
            "head_age_seconds": {
              "type": "integer"
            },
            "head_enqueued_at_unix": {
              "type": "integer"
            },
            "head_message_id": {
              "type": "string"
            },
            "head_not_visible_until_unix": {
              "type": "integer"
            },
            "namespace": {
              "type": "string"
            },
            "pending_candidates": {
              "type": "integer"
            },
            "queue": {
              "type": "string"
            },
            "total_consumers": {
              "type": "integer"
            },
            "waiting_consumers": {
              "type": "integer"
            }
          },
          "required": [
            "namespace",
            "queue",
            "waiting_consumers",
            "pending_candidates",
            "total_consumers",
            "has_active_watcher",
            "available"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Subscribe current MCP session to queue-availability notifications over SSE.\nUse when: You run a long-lived MCP runtime and want ongoing push wake-ups instead of pure dequeue polling.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Registers session subscription; future queue activity emits MCP progress notifications.\nRetry: Safe to retry; duplicate subscribe is handled as already subscribed.\nNext: On notification, call `lockd.queue.dequeue` then `ack` or `defer`.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name (defaults to lockd.agent.bus)",
              "type": "string"
            }
          },
          "type": "object"
        },
        "name": "lockd.queue.subscribe",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "namespace": {
              "type": "string"
            },
            "queue": {
              "type": "string"
            },
            "subscribed": {
              "type": "boolean"
            }
          },
          "required": [
            "namespace",
            "queue",
            "subscribed"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Remove current MCP session queue subscription.\nUse when: Worker no longer wants notifications for a queue.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\".\nEffects: Stops notification forwarding for the targeted session+queue binding.\nRetry: Safe to retry; unsubscribing an absent subscription returns false/unsubscribed state.\nNext: Either resubscribe later or continue with explicit dequeue polling.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name (defaults to lockd.agent.bus)",
              "type": "string"
            }
          },
          "type": "object"
        },
        "name": "lockd.queue.unsubscribe",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "namespace": {
              "type": "string"
            },
            "queue": {
              "type": "string"
            },
            "unsubscribed": {
              "type": "boolean"
            }
          },
          "required": [
            "namespace",
            "queue",
            "unsubscribed"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Wait for queue-availability events within a bounded call window.\nUse when: Interactive clients need push-like wakeups without maintaining long-lived subscriptions.\nRequires: `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\". Optional `duration_seconds` bounds wait time (default 30). Optional `max_events` bounds result size (default 1).\nEffects: Streams watch events from upstream lockd and returns a bounded event list with `stop_reason` (`max_events`, `timeout`, or `context_canceled`).\nRetry: Safe to retry; each invocation is independent and bounded.\nNext: After any event, call `lockd.queue.dequeue` and then `ack`/`nack`/`defer`.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "duration_seconds": {
              "description": "Maximum watch duration in seconds (default: 30)",
              "type": "integer"
            },
            "max_events": {
              "description": "Maximum events to return before stopping (default: 1)",
              "type": "integer"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name (defaults to lockd.agent.bus)",
              "type": "string"
            }
          },
          "type": "object"
        },
        "name": "lockd.queue.watch",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "event_count": {
              "type": "integer"
            },
            "events": {
              "items": {
                "additionalProperties": false,
                "properties": {
                  "available": {
                    "type": "boolean"
                  },
                  "changed_at_unix": {
                    "type": "integer"
                  },
                  "correlation_id": {
                    "type": "string"
                  },
                  "head_message_id": {
                    "type": "string"
                  },
                  "namespace": {
                    "type": "string"
                  },
                  "queue": {
                    "type": "string"
                  }
                },
                "required": [
                  "namespace",
                  "queue",
                  "available"
                ],
                "type": "object"
              },
              "type": [
                "null",
                "array"
              ]
            },
            "namespace": {
              "type": "string"
            },
            "queue": {
              "type": "string"
            },
            "stop_reason": {
              "type": "string"
            }
          },
          "required": [
            "namespace",
            "queue",
            "events",
            "event_count",
            "stop_reason"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Abort an in-flight queue write stream.\nUse when: Queued payload upload should be canceled.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates upload flow and frees stream resources.\nRetry: Safe to retry; absent streams return not-found style errors.\nNext: Begin a new queue stream if publish should be retried.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "reason": {
              "description": "Optional abort reason for diagnostics",
              "type": "string"
            },
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id"
          ],
          "type": "object"
        },
        "name": "lockd.queue.write_stream.abort",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "aborted": {
              "type": "boolean"
            },
            "bytes_received": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "aborted",
            "bytes_received"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Append one base64 chunk into an open queue write stream.\nUse when: You are streaming large queue payload content.\nRequires: Active MCP session is required. `stream_id` and `chunk_base64` are required. Decoded chunk must be \u003c= 2097152 bytes.\nEffects: Writes chunk bytes directly to the upstream enqueue request stream and returns append/total byte counts.\nRetry: Do not blindly retry the same chunk without stream-position tracking; repeated append can duplicate bytes.\nNext: Continue appending until complete, then `lockd.queue.write_stream.commit`.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "chunk_base64": {
              "description": "Base64-encoded payload chunk bytes",
              "type": "string"
            },
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "chunk_base64"
          ],
          "type": "object"
        },
        "name": "lockd.queue.write_stream.append",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "bytes_appended": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            },
            "total_bytes": {
              "type": "integer"
            }
          },
          "required": [
            "stream_id",
            "bytes_appended",
            "total_bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Open a session-scoped streaming queue publisher.\nUse when: Queue payload is too large for inline enqueue or you need bounded-memory uploads.\nRequires: Active MCP session is required. `queue` defaults to \"lockd.agent.bus\" and `namespace` defaults to \"mcp\". Delay/visibility/ttl/attributes/content_type options match `lockd.queue.enqueue`.\nEffects: Creates a stream session and returns `stream_id` plus one-time `upload_url` for direct HTTP PUT upload.\nRetry: Not idempotent; begin returns a new stream each time. Abort unused streams explicitly.\nNext: Upload bytes to `upload_url`, then call `lockd.queue.write_stream.commit` (or `abort`).",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "attributes": {
              "additionalProperties": true,
              "description": "Message attributes metadata",
              "type": "object"
            },
            "content_type": {
              "description": "Payload content type",
              "type": "string"
            },
            "delay_seconds": {
              "description": "Initial invisibility delay",
              "type": "integer"
            },
            "max_attempts": {
              "description": "Maximum failed attempts before terminal handling",
              "type": "integer"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "queue": {
              "description": "Queue name (defaults to lockd.agent.bus)",
              "type": "string"
            },
            "ttl_seconds": {
              "description": "Message retention TTL in seconds",
              "type": "integer"
            },
            "visibility_seconds": {
              "description": "Visibility timeout for dequeued lease",
              "type": "integer"
            }
          },
          "type": "object"
        },
        "name": "lockd.queue.write_stream.begin",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "max_chunk_bytes": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            },
            "upload_expires_at_unix": {
              "type": "integer"
            },
            "upload_method": {
              "type": "string"
            },
            "upload_url": {
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "max_chunk_bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Finalize a queue write stream and publish the message.\nUse when: All payload chunks for a queued message have been appended.\nRequires: Active MCP session and `stream_id` are required.\nEffects: Closes upload stream, waits for upstream enqueue completion, and returns enqueue metadata.\nRetry: Commit is terminal for a stream_id. On failure, begin a new stream and replay payload.\nNext: Use dequeue/ack workflows on consuming agents.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id"
          ],
          "type": "object"
        },
        "name": "lockd.queue.write_stream.commit",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "attempts": {
              "type": "integer"
            },
            "bytes_received": {
              "type": "integer"
            },
            "correlation_id": {
              "type": "string"
            },
            "failure_attempts": {
              "type": "integer"
            },
            "max_attempts": {
              "type": "integer"
            },
            "message_id": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "not_visible_until_unix": {
              "type": "integer"
            },
            "payload_bytes": {
              "type": "integer"
            },
            "queue": {
              "type": "string"
            },
            "stream_id": {
              "type": "string"
            },
            "visibility_timeout_seconds": {
              "type": "integer"
            }
          },
          "required": [
            "stream_id",
            "bytes_received",
            "namespace",
            "queue",
            "message_id",
            "attempts",
            "max_attempts",
            "not_visible_until_unix",
            "visibility_timeout_seconds",
            "payload_bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Update state metadata without replacing JSON state payload.\nUse when: Only metadata (for example `query_hidden`) needs to change.\nRequires: `key`, `lease_id`, and `query_hidden` are required. `namespace` defaults to \"mcp\". Optional CAS/fencing fields protect against races.\nEffects: Persists metadata mutation and returns resulting version/metadata.\nRetry: Use CAS/fencing fields for deterministic retries; otherwise last-writer-wins behavior applies.\nNext: Continue updates under the same lease or release the lease when done.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "if_etag": {
              "description": "Conditional ETag guard",
              "type": "string"
            },
            "if_version": {
              "description": "Conditional version guard",
              "type": [
                "null",
                "integer"
              ]
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "query_hidden": {
              "description": "Set true to hide, false to expose in queries",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id",
            "query_hidden"
          ],
          "type": "object"
        },
        "name": "lockd.state.metadata",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "query_hidden": {
              "type": [
                "null",
                "boolean"
              ]
            },
            "version": {
              "type": "integer"
            }
          },
          "required": [
            "version"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Apply an RFC 7396 JSON merge patch to current state under lease protection.\nUse when: You need partial updates without sending a full replacement document.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Provide exactly one of `patch_text` or `patch_base64` and keep patch/result within inline limits; use `state.write_stream` for large documents.\nEffects: Loads current state (lease-bound read), applies merge patch, then writes updated state and returns new version/ETag metadata.\nRetry: Use `if_etag`, `if_version`, and `fencing_token` for safe retries. Patch retries without guards can duplicate logical effects.\nNext: Use `lockd.get`/`lockd.state.stream` to verify result, then release lease.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "if_etag": {
              "description": "Conditional ETag guard",
              "type": "string"
            },
            "if_version": {
              "description": "Conditional version guard",
              "type": [
                "null",
                "integer"
              ]
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "patch_base64": {
              "description": "Base64-encoded JSON merge patch document",
              "type": "string"
            },
            "patch_text": {
              "description": "UTF-8 JSON merge patch document",
              "type": "string"
            },
            "query_hidden": {
              "description": "Optional query-hidden metadata mutation",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id"
          ],
          "type": "object"
        },
        "name": "lockd.state.patch",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "bytes": {
              "type": "integer"
            },
            "new_state_etag": {
              "type": "string"
            },
            "new_version": {
              "type": "integer"
            },
            "query_hidden": {
              "type": [
                "null",
                "boolean"
              ]
            }
          },
          "required": [
            "new_version",
            "new_state_etag",
            "bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Delete state for a key under lease protection.\nUse when: State should be removed as part of cleanup or workflow transitions.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional `txn_id` and CAS/fencing fields support XA/concurrency control.\nEffects: Removes committed state for the key (or stages delete in transaction context).\nRetry: Prefer CAS/fencing guards for deterministic retries; repeated deletes may be no-op or not-found depending on timing.\nNext: Release lease to finalize, or write replacement state/attachments first.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "if_etag": {
              "description": "Conditional ETag guard",
              "type": "string"
            },
            "if_version": {
              "description": "Conditional version guard",
              "type": [
                "null",
                "integer"
              ]
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id"
          ],
          "type": "object"
        },
        "name": "lockd.state.remove",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "new_version": {
              "type": "integer"
            },
            "removed": {
              "type": "boolean"
            }
          },
          "required": [
            "removed"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Create a one-time download capability URL for state payload bytes.\nUse when: You need state content (small or large) without routing payload through MCP tool responses.\nRequires: Active MCP session is required. `key` is required. `namespace` defaults to \"mcp\". `public` defaults to true; set `public=false` with `lease_id` for lease-bound reads.\nEffects: Returns metadata plus one-time `download_url` and `download_method` for direct HTTP download.\nRetry: Safe to retry; each call creates a new one-time URL.\nNext: Fetch `download_url` directly with the returned method, then continue lock/query workflow.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Lease ID required when public=false",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "public": {
              "description": "Read mode selector: true for public read (default), false for lease-bound read",
              "type": [
                "null",
                "boolean"
              ]
            }
          },
          "required": [
            "key"
          ],
          "type": "object"
        },
        "name": "lockd.state.stream",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "download_expires_at_unix": {
              "type": "integer"
            },
            "download_method": {
              "type": "string"
            },
            "download_url": {
              "type": "string"
            },
            "etag": {
              "type": "string"
            },
            "found": {
              "type": "boolean"
            },
            "key": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "version": {
              "type": "integer"
            }
          },
          "required": [
            "namespace",
            "key",
            "found"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Write JSON state under lease protection.\nUse when: You need to create or update state for a locked key and payload fits inline request limits.\nRequires: `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Payload comes from exactly one of `payload_text` or `payload_base64` (defaults to `{}`) and must be \u003c= 2097152 bytes after decoding.\nEffects: Updates state and returns new version/ETag metadata; can also mutate `query_hidden` metadata.\nRetry: Use `if_etag`, `if_version`, and `fencing_token` for safe retries. Without guards, retries can apply duplicate writes.\nNext: For larger payloads use `lockd.state.write_stream.begin` and upload to returned `upload_url`, then `commit`; release lease to commit or rollback.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "if_etag": {
              "description": "Conditional ETag guard",
              "type": "string"
            },
            "if_version": {
              "description": "Conditional version guard",
              "type": [
                "null",
                "integer"
              ]
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "payload_base64": {
              "description": "Base64-encoded JSON payload bytes",
              "type": "string"
            },
            "payload_text": {
              "description": "UTF-8 JSON payload text",
              "type": "string"
            },
            "query_hidden": {
              "description": "Optional query-hidden metadata mutation",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id"
          ],
          "type": "object"
        },
        "name": "lockd.state.update",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "bytes": {
              "type": "integer"
            },
            "new_state_etag": {
              "type": "string"
            },
            "new_version": {
              "type": "integer"
            },
            "query_hidden": {
              "type": [
                "null",
                "boolean"
              ]
            }
          },
          "required": [
            "new_version",
            "new_state_etag",
            "bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Abort an in-flight state write stream.\nUse when: Upload should be canceled or discarded before commit.\nRequires: Active MCP session and `stream_id` are required. Optional `reason` is advisory.\nEffects: Terminates the stream, cancels upstream request flow, and frees stream resources.\nRetry: Safe to retry; absent streams return not-found style errors.\nNext: Begin a new stream if upload should be retried.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "reason": {
              "description": "Optional abort reason for diagnostics",
              "type": "string"
            },
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id"
          ],
          "type": "object"
        },
        "name": "lockd.state.write_stream.abort",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "aborted": {
              "type": "boolean"
            },
            "bytes_received": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "aborted",
            "bytes_received"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Append one base64 chunk into an open state write stream.\nUse when: You are actively streaming large state payload content.\nRequires: Active MCP session is required. `stream_id` and `chunk_base64` are required. Decoded chunk must be \u003c= 2097152 bytes.\nEffects: Writes chunk bytes directly to the upstream update request stream and returns append/total byte counts.\nRetry: Do not blindly retry the same chunk without stream-position tracking; repeated append can duplicate bytes.\nNext: Continue appending until complete, then `lockd.state.write_stream.commit`.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "chunk_base64": {
              "description": "Base64-encoded payload chunk bytes",
              "type": "string"
            },
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "chunk_base64"
          ],
          "type": "object"
        },
        "name": "lockd.state.write_stream.append",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "bytes_appended": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            },
            "total_bytes": {
              "type": "integer"
            }
          },
          "required": [
            "stream_id",
            "bytes_appended",
            "total_bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Open a session-scoped streaming state writer.\nUse when: State payload is too large for inline JSON or you want bounded-memory uploads.\nRequires: Active MCP session is required. `key` and `lease_id` are required. `namespace` defaults to \"mcp\". Optional CAS/fencing fields mirror `lockd.state.update`.\nEffects: Creates a stream session and returns `stream_id` plus one-time `upload_url` for direct HTTP PUT upload outside MCP tool payload context.\nRetry: Not idempotent; begin returns a new stream each time. Abort unused streams explicitly.\nNext: Upload bytes to `upload_url`, then call `lockd.state.write_stream.commit` (or `abort`).",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "fencing_token": {
              "description": "Optional fencing token override",
              "type": [
                "null",
                "integer"
              ]
            },
            "if_etag": {
              "description": "Conditional ETag guard",
              "type": "string"
            },
            "if_version": {
              "description": "Conditional version guard",
              "type": [
                "null",
                "integer"
              ]
            },
            "key": {
              "description": "State key",
              "type": "string"
            },
            "lease_id": {
              "description": "Active lease id",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace (defaults to server default namespace)",
              "type": "string"
            },
            "query_hidden": {
              "description": "Optional query-hidden metadata mutation",
              "type": [
                "null",
                "boolean"
              ]
            },
            "txn_id": {
              "description": "Optional XA transaction id",
              "type": "string"
            }
          },
          "required": [
            "key",
            "lease_id"
          ],
          "type": "object"
        },
        "name": "lockd.state.write_stream.begin",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "max_chunk_bytes": {
              "type": "integer"
            },
            "stream_id": {
              "type": "string"
            },
            "upload_expires_at_unix": {
              "type": "integer"
            },
            "upload_method": {
              "type": "string"
            },
            "upload_url": {
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "max_chunk_bytes"
          ],
          "type": "object"
        }
      },
      {
        "description": "Purpose: Finalize a state write stream and commit it to upstream lockd.\nUse when: All payload chunks have been appended.\nRequires: Active MCP session and `stream_id` are required.\nEffects: Closes the upload stream, waits for upstream completion, and returns state update result metadata.\nRetry: Commit is terminal for a stream_id. On failure, begin a new stream and replay payload.\nNext: Release lease or proceed with additional state/attachment mutations.",
        "inputSchema": {
          "additionalProperties": false,
          "properties": {
            "stream_id": {
              "description": "Write stream identifier returned by begin",
              "type": "string"
            }
          },
          "required": [
            "stream_id"
          ],
          "type": "object"
        },
        "name": "lockd.state.write_stream.commit",
        "outputSchema": {
          "additionalProperties": false,
          "properties": {
            "bytes": {
              "type": "integer"
            },
            "bytes_received": {
              "type": "integer"
            },
            "new_state_etag": {
              "type": "string"
            },
            "new_version": {
              "type": "integer"
            },
            "query_hidden": {
              "type": [
                "null",
                "boolean"
              ]
            },
            "stream_id": {
              "type": "string"
            }
          },
          "required": [
            "stream_id",
            "bytes_received",
            "new_version",
            "new_state_etag",
            "bytes"
          ],
          "type": "object"
        }
      }
    ]
  }
}
