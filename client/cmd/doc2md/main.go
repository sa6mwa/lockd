package main

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	const (
		docFile     = "doc.go"
		readmeFile  = "README.md"
		generatedBy = "<!-- Code generated by go generate; DO NOT EDIT. -->\n\n"
	)

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, docFile, nil, parser.ParseComments)
	if err != nil {
		fail("parse %s: %v", docFile, err)
	}
	if file.Doc == nil {
		fail("%s: missing package comment", docFile)
	}

	text := strings.TrimSpace(file.Doc.Text())
	if text == "" {
		fail("%s: package comment is empty", docFile)
	}

	text = convertDocToMarkdown(text)

	var buf bytes.Buffer
	buf.WriteString(generatedBy)
	buf.WriteString(text)
	if !strings.HasSuffix(text, "\n") {
		buf.WriteString("\n")
	}

	if err := os.WriteFile(readmeFile, buf.Bytes(), 0o644); err != nil {
		fail("write %s: %v", readmeFile, err)
	}
	abs, _ := filepath.Abs(readmeFile)
	fmt.Printf("wrote %s\n", abs)
}

func fail(format string, args ...any) {
	fmt.Fprintf(os.Stderr, format+"\n", args...)
	os.Exit(1)
}

func convertDocToMarkdown(in string) string {
	lines := strings.Split(in, "\n")
	var out []string
	inCode := false
	for _, line := range lines {
		switch {
		case strings.HasPrefix(line, "\t"):
			if !inCode {
				out = append(out, "```go")
				inCode = true
			}
			out = append(out, strings.TrimPrefix(line, "\t"))
		case strings.HasPrefix(line, "    "):
			if !inCode {
				out = append(out, "```go")
				inCode = true
			}
			out = append(out, strings.TrimPrefix(line, "    "))
		case line == "" && inCode:
			out = append(out, "")
		default:
			if inCode {
				out = append(out, "```")
				inCode = false
			}
			out = append(out, line)
		}
	}
	if inCode {
		out = append(out, "```")
	}
	return strings.Join(out, "\n")
}
